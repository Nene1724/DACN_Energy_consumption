
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IoT ML Energy Manager</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <style>
        :root {
            --bg: #f5f7fb;
            --panel: #ffffff;
            --panel-alt: #f2f6ff;
            --border: #e4eaf2;
            --text: #0b1b32;
            --muted: #5b6b80;
            --accent: #3b82f6;
            --accent-strong: #2563eb;
            --danger: #dc2626;
            --warning: #f59e0b;
            --success: #16a34a;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Plus Jakarta Sans', 'Segoe UI', Tahoma, sans-serif;
            background: radial-gradient(circle at 14% 16%, rgba(59,130,246,0.14), transparent 32%), radial-gradient(circle at 82% 10%, rgba(16,185,129,0.14), transparent 28%), linear-gradient(180deg, #f5f7fb 0%, #eef2ff 100%);
            color: var(--text);
            min-height: 100vh;
            line-height: 1.55;
        }
        .shell { max-width: 1600px; margin: 0 auto; padding: 28px 22px 48px; }
        .page-title { text-align: center; margin-bottom: 22px; }
        .page-title h1 { 
            font-size: 28px; 
            font-weight: 800; 
            letter-spacing: 0.6px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            gap: 12px;
            text-shadow: 0 0 20px rgba(34, 211, 238, 0.6), 0 0 40px rgba(34, 211, 238, 0.3);
            animation: titleGlow 3s ease-in-out infinite;
        }
        @keyframes titleGlow {
            0%, 100% { text-shadow: 0 0 20px rgba(34, 211, 238, 0.6), 0 0 40px rgba(34, 211, 238, 0.3); }
            50% { text-shadow: 0 0 30px rgba(34, 211, 238, 0.9), 0 0 60px rgba(34, 211, 238, 0.5), 0 0 80px rgba(34, 211, 238, 0.2); }
        }
        .page-title h1::before {
            content: '';
            display: inline-block;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: radial-gradient(circle, #22d3ee, #0ea5e9);
            box-shadow: 0 0 15px rgba(34, 211, 238, 0.8), 0 0 30px rgba(34, 211, 238, 0.5);
            animation: dotPulse 2s ease-in-out infinite;
        }
        @keyframes dotPulse {
            0%, 100% { box-shadow: 0 0 15px rgba(34, 211, 238, 0.8), 0 0 30px rgba(34, 211, 238, 0.5); transform: scale(1); }
            50% { box-shadow: 0 0 25px rgba(34, 211, 238, 1), 0 0 50px rgba(34, 211, 238, 0.7), 0 0 70px rgba(34, 211, 238, 0.4); transform: scale(1.15); }
        }
        .page-title p { color: var(--muted); margin-top: 6px; }
        .section-lede { display: flex; justify-content: space-between; align-items: flex-start; gap: 16px; flex-wrap: wrap; margin-bottom: 8px; }
        .section-lede h2 { font-size: 22px; }
        .section-lede p { color: var(--muted); line-height: 1.6; max-width: 780px; }
        .chip-row { display: flex; gap: 10px; flex-wrap: wrap; margin: 10px 0; }
        .chip { padding: 6px 12px; border-radius: 999px; background: rgba(34,211,238,0.12); color: var(--accent); font-weight: 600; font-size: 12px; letter-spacing: 0.03em; }
        .filter-bar { display: flex; justify-content: space-between; align-items: center; gap: 12px; flex-wrap: wrap; margin: 8px 0 16px; }
        .filter-note { color: var(--muted); font-size: 12px; }
        .inline-stats { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; color: var(--muted); font-size: 13px; }
        .inline-stats strong { color: var(--text); margin-left: 4px; }
        .grid { display: grid; grid-template-columns: minmax(360px, 450px) 1fr; gap: 14px; }
        .panel { background: linear-gradient(180deg, #ffffff 0%, #f3f7ff 100%); border: 1px solid var(--border); border-radius: 18px; padding: 16px; box-shadow: 0 14px 30px rgba(15,23,42,0.06); margin-bottom: 14px; }
        .panel-header { display: flex; justify-content: space-between; align-items: center; gap: 12px; margin-bottom: 12px; }
        .panel-actions { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
        .panel-header h3 { font-size: 18px; }
        .panel-header .muted { color: var(--muted); font-size: 13px; }
        .form-grid { display: grid; gap: 14px; }
        .form-control { margin-bottom: 4px; overflow: hidden; }
        .form-control label { font-size: 13px; color: var(--text); font-weight: 600; display: block; margin-bottom: 6px; letter-spacing: 0.01em; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; line-height: 1.2; }
        .form-control input, .form-control select { width: 100%; padding: 12px 14px; border-radius: 10px; border: 1.5px solid var(--border); background: #ffffff; color: var(--text); font-size: 14px; transition: all 0.2s; box-sizing: border-box; }
        .form-control input:focus, .form-control select:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1); }
        .form-control input:disabled { background: #f1f5f9; color: var(--muted); cursor: not-allowed; }
        .btn { border: 1px solid transparent; border-radius: 12px; padding: 12px 16px; font-weight: 700; font-size: 14px; cursor: pointer; transition: all 0.2s; color: var(--text); background: #f2f5fb; text-align: center; display: inline-flex; align-items: center; justify-content: center; gap: 8px; }
        .btn.primary { background: linear-gradient(135deg, #3b82f6, #22d3ee); color: #ffffff; border-color: transparent; box-shadow: 0 8px 16px rgba(59, 130, 246, 0.2); }
        .btn.primary:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 12px 20px rgba(59, 130, 246, 0.3); }
        .btn.ghost { border-color: var(--border); background: transparent; color: var(--text); font-weight: 600; }
        .btn.ghost:hover:not(:disabled) { border-color: var(--accent); color: var(--accent); background: rgba(59, 130, 246, 0.05); }
        .btn.full { width: 100%; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .status-row { display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 12px; }
        .status-block { border: 1.5px solid var(--border); border-radius: 12px; padding: 14px 16px; background: linear-gradient(180deg, #ffffff, #fafbff); box-shadow: 0 2px 8px rgba(15, 23, 42, 0.04); }
        
        /* Download model */
        .download-model-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.5); backdrop-filter: blur(4px); z-index: 9999; display: none; align-items: center; justify-content: center; }
        .download-model-overlay.active { display: flex; }
        .download-model { background: white; border-radius: 16px; padding: 24px; max-width: 500px; width: 90%; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3); }
        .download-model h3 { margin-bottom: 12px; font-size: 20px; }
        .download-model p { color: var(--muted); margin-bottom: 20px; line-height: 1.6; }
        .download-progress { margin: 20px 0; }
        .download-progress-bar { height: 8px; background: var(--border); border-radius: 4px; overflow: hidden; margin-top: 8px; }
        .download-progress-fill { height: 100%; background: linear-gradient(90deg, var(--accent), var(--success)); transition: width 0.3s; }
        .download-status { font-size: 13px; color: var(--muted); margin-top: 8px; }
        .model-actions { display: flex; gap: 12px; justify-content: flex-end; margin-top: 20px; }
        .status-title { color: var(--muted); font-size: 11px; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600; }
        .status-value { font-weight: 600; font-size: 15px; display: flex; align-items: center; gap: 8px; color: var(--text); line-height: 1.4; }
        .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-flex; }
        .dot.idle { background: #475569; }
        .dot.downloading { background: var(--warning); animation: pulse 1.4s infinite; }
        .dot.ready { background: var(--success); }
        .dot.running { background: var(--accent); animation: pulse 1.4s infinite; }
        .dot.error { background: var(--danger); }
        @keyframes pulse { 0%,100%{opacity:1;} 50%{opacity:0.5;} }
        .energy-grid { display: grid; grid-template-columns: repeat(4, minmax(0,1fr)); gap: 10px; }
        .energy-card { border: 1px solid var(--border); border-radius: 12px; padding: 10px; background: #ffffff; }
        .energy-card small { color: var(--muted); font-size: 12px; }
        .energy-card .value { font-size: 18px; font-weight: 700; margin-top: 4px; }
        .badge { padding: 6px 10px; border-radius: 999px; font-size: 11px; letter-spacing: 0.05em; font-weight: 700; display: inline-flex; align-items: center; gap: 6px; }
        .badge.ok { background: rgba(52,211,153,0.16); color: var(--success); }
        .badge.over { background: rgba(244,63,94,0.16); color: var(--danger); }
        .history-list { list-style: none; margin-top: 10px; display: flex; flex-direction: column; gap: 6px; color: var(--muted); font-size: 12px; }
        .history-list li { display: flex; justify-content: space-between; border-bottom: 1px dashed var(--border); padding-bottom: 6px; }
        .history-list li:last-child { border-bottom: none; }
        .filter-select { padding: 10px 12px; border-radius: 10px; border: 1px solid var(--border); background: #ffffff; color: var(--text); font-weight: 600; min-width: 190px; }
        .library-filter-bar { display: flex; justify-content: flex-end; align-items: center; gap: 12px; margin: 4px 0 10px; }
        .model-list { margin-top: 14px; display: flex; flex-direction: column; gap: 10px; max-height: 570px; overflow-y: auto; padding-right: 4px; }
        .model-grid { margin-top: 14px; display: flex; flex-direction: column; gap: 6px; max-height: 570px; overflow-y: auto; padding-right: 4px; }
        .model-item { border: 1px solid var(--border); border-radius: 14px; padding: 12px; background: #ffffff; cursor: pointer; transition: border 0.2s, transform 0.2s; }
        .model-item:hover { border-color: var(--accent); transform: translateY(-2px); }
        .model-item.selected { border-color: var(--accent-strong); box-shadow: 0 0 0 1px var(--accent-strong); }
        .model-item.recommended { border-color: rgba(52,211,153,0.4); }
        .model-head { display: flex; justify-content: space-between; gap: 10px; align-items: center; flex-wrap: wrap; }
        .model-name { font-size: 16px; font-weight: 700; display: flex; gap: 8px; align-items: center; }
        .model-actions { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
        .status-pill { padding: 4px 8px; border-radius: 8px; font-size: 11px; font-weight: 700; letter-spacing: 0.02em; }
        .status-pill.ok { background: rgba(52,211,153,0.16); color: var(--success); }
        .status-pill.warn { background: rgba(244,63,94,0.16); color: var(--danger); }
        .model-meta { display: flex; flex-wrap: wrap; gap: 12px; color: var(--muted); font-size: 12px; margin: 6px 0 4px; }
        .model-reason { color: var(--success); font-size: 12px; }
        .pill { background: rgba(52,211,153,0.16); color: var(--success); border-radius: 999px; padding: 2px 8px; font-size: 10px; letter-spacing: 0.05em; font-weight: 700; }
        .selection-preview { margin-top: 12px; border: 1px dashed var(--border); border-radius: 12px; padding: 12px; background: #ffffff; color: var(--muted); font-size: 13px; }
        .selection-preview strong { color: var(--text); }
        .selection-preview .risk { color: var(--danger); font-weight: 700; }
        .timeline-wrapper { max-height: 280px; overflow-y: auto; padding-right: 6px; }
        .timeline { list-style: none; display: flex; flex-direction: column; gap: 10px; }
        .timeline-entry { display: flex; gap: 12px; padding: 10px; border: 1px solid var(--border); border-radius: 12px; background: #ffffff; }
        .timeline-dot { width: 12px; height: 12px; border-radius: 50%; margin-top: 6px; background: var(--accent); }
        .timeline-entry.success .timeline-dot { background: var(--success); }
        .timeline-entry.error .timeline-dot { background: var(--danger); }
        .timeline-entry.info .timeline-dot { background: var(--accent); }
        .timeline-time { font-size: 12px; color: var(--muted); }
        .timeline-text { font-size: 14px; }
        .timeline-empty { color: var(--muted); font-size: 13px; padding: 12px 4px; }
        .alert-stack { margin: 12px 0; }
        .alert { padding: 12px 14px; border-radius: 12px; font-weight: 700; border: 1px solid var(--border); }
        .alert.success { background: rgba(52,211,153,0.12); color: var(--success); border-color: rgba(52,211,153,0.3); }
        .alert.error { background: rgba(244,63,94,0.12); color: var(--danger); border-color: rgba(244,63,94,0.3); }
        .alert.info { background: rgba(34,211,238,0.12); color: var(--accent); border-color: rgba(34,211,238,0.3); }
        .loading-state { text-align: center; padding: 24px 0; color: var(--muted); }
        .spinner { width: 26px; height: 26px; border: 3px solid var(--border); border-top-color: var(--accent); border-radius: 50%; margin: 0 auto 8px; animation: spin 0.9s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .predict-grid { display: grid; grid-template-columns: repeat(3, minmax(0,1fr)); gap: 8px; }
        .predict-output { border: 1px dashed var(--border); border-radius: 12px; padding: 12px; background: #ffffff; margin-top: 10px; font-size: 13px; }
        .balena-list { display: flex; flex-direction: column; gap: 10px; max-height: 340px; overflow-y: auto; padding-right: 4px; }
        .balena-item { border: 1px solid var(--border); border-radius: 12px; padding: 12px; background: #ffffff; display: flex; flex-direction: column; gap: 10px; }
        .balena-head { display: flex; justify-content: space-between; align-items: flex-start; gap: 12px; flex-wrap: wrap; }
        .balena-meta { color: var(--muted); font-size: 12px; display: flex; flex-direction: column; gap: 3px; }
        .balena-actions { display: flex; gap: 8px; align-items: center; }
        .device-list { display: flex; flex-direction: column; gap: 6px; max-height: 320px; overflow-y: auto; overflow-x: hidden; padding: 8px; border: 1px solid var(--border); border-radius: 10px; background: #f8fafc; }
        .device-list::-webkit-scrollbar { width: 6px; }
        .device-list::-webkit-scrollbar-track { background: #f1f5f9; border-radius: 10px; }
        .device-list::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; }
        .device-list::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        .device-item { display: flex; align-items: center; gap: 10px; padding: 10px 12px; border: 1.5px solid var(--border); border-radius: 8px; background: #ffffff; cursor: pointer; transition: all 0.2s ease; min-height: 54px; }
        .device-item:hover:not(.disabled) { border-color: var(--accent); background: rgba(59, 130, 246, 0.04); box-shadow: 0 2px 8px rgba(59, 130, 246, 0.08); }
        .device-item.selected { border-color: var(--accent); background: rgba(59, 130, 246, 0.1); box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2); position: relative; }
        .device-item.selected::before { content: '✓'; position: absolute; left: 10px; top: 50%; transform: translateY(-50%); width: 20px; height: 20px; border-radius: 4px; background: var(--success); color: white; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 14px; }
        .device-item.disabled { opacity: 0.55; cursor: not-allowed; background: #fafbfc; }
        .device-item.disabled:hover { border-color: var(--border); background: #fafbfc; box-shadow: none; }
        .device-checkbox { display: none; }
        .device-checkbox:disabled { cursor: not-allowed; opacity: 0.5; }
        .device-info { flex: 1; display: flex; flex-direction: column; gap: 2px; min-width: 0; overflow: visible; }
        .device-item.selected .device-info { padding-left: 26px; }
        .device-name { font-weight: 600; color: var(--text); font-size: 13px; line-height: 1.2; display: flex; align-items: center; gap: 6px; flex-wrap: wrap; word-break: break-word; }
        .device-details { font-size: 11px; color: var(--muted); display: flex; align-items: center; gap: 6px; line-height: 1.2; flex-wrap: wrap; word-break: break-word; }
        .device-status-badge { display: inline-flex; align-items: center; gap: 3px; padding: 2px 6px; border-radius: 8px; font-size: 9px; font-weight: 700; letter-spacing: 0.03em; text-transform: uppercase; white-space: nowrap; }
        .device-status-badge.online { background: rgba(16, 185, 129, 0.15); color: #047857; border: 1px solid rgba(16, 185, 129, 0.25); }
        .device-status-badge.offline { background: rgba(239, 68, 68, 0.15); color: #b91c1c; border: 1px solid rgba(239, 68, 68, 0.25); }
        .device-status-badge::before { content: ''; width: 4px; height: 4px; border-radius: 50%; background: currentColor; }
        .device-ip { font-family: 'Courier New', monospace; color: var(--text); font-size: 11px; font-weight: 500; }
        .mini-btn { border: 1px solid var(--border); background: transparent; color: var(--accent); border-radius: 10px; padding: 6px 10px; font-size: 12px; cursor: pointer; }
        .monitor-tabs { display:flex; gap:12px; align-items:flex-end; border-bottom:1px solid var(--border); padding-bottom:6px; margin-bottom:14px; flex-wrap:wrap; }
        .monitor-tab { padding:10px 2px; border:none; border-bottom:2px solid transparent; background:transparent; color:var(--muted); cursor:pointer; font-weight:700; letter-spacing:0.02em; }
        .monitor-tab.active { color: var(--text); border-bottom-color: var(--accent); }
        .monitor-content { display:flex; flex-direction:column; gap:14px; }
        .monitor-row { display:grid; grid-template-columns: repeat(auto-fit, minmax(320px,1fr)); gap:12px; }
        .monitor-card { border:1px solid var(--border); border-radius:14px; padding:14px; background: linear-gradient(180deg, #ffffff, #eef3ff); color:var(--muted); box-shadow: 0 10px 26px rgba(15,23,42,0.08); transition: transform 0.2s ease, box-shadow 0.2s ease; }
        .monitor-card:hover { transform: translateY(-2px); box-shadow: 0 12px 32px rgba(15,23,42,0.12); }
        .monitor-card h4 { color: var(--text); margin-bottom:6px; font-size:16px; }
        .monitor-card small { color: var(--muted); }
        .bar-row { display:flex; align-items:center; gap:8px; margin:6px 0; }
        .bar { height:8px; border-radius:8px; background: linear-gradient(90deg, #22d3ee, #0ea5e9); flex:1; }
        .kpi { display:flex; flex-direction:column; gap:4px; padding:12px; border:1px solid var(--border); border-radius:12px; background:#ffffff; }
        .kpi small { color: var(--muted); }
        .kpi strong { font-size:18px; }
        .metric-list { display:flex; flex-direction:column; gap:6px; }
        .metric-line { display:flex; align-items:center; gap:10px; }
        .metric-line span.label { min-width:120px; color:var(--text); font-weight:600; }
        .metric-line .value { color:var(--muted); min-width:80px; text-align:right; }
        .pill-sm { padding:4px 8px; border-radius:999px; font-size:11px; border:1px solid var(--border); color:var(--text); background: rgba(34,211,238,0.08); }
        .log-list { display: flex; flex-direction: column; gap: 8px; max-height: 550px; overflow-y: auto; padding: 4px; }
        .log-entry { border: 1px solid var(--border); border-radius: 8px; padding: 8px; background: #ffffff; }
        .log-entry.ok { border-left: 3px solid var(--success); }
        .log-entry.error { border-left: 3px solid var(--danger); }
        .log-entry.info { border-left: 3px solid var(--accent); }
        .log-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
        .log-time { font-size: 11px; color: var(--muted); font-family: monospace; }
        .log-type { font-size: 9px; font-weight: 700; padding: 2px 6px; border-radius: 3px; }
        .log-type.ok { background: rgba(52,211,153,0.16); color: var(--success); }
        .log-type.error { background: rgba(244,63,94,0.16); color: var(--danger); }
        .log-type.info { background: rgba(59,130,246,0.16); color: var(--accent); }
        .log-message { font-size: 13px; color: var(--text); }
        .device-log-entry { padding: 6px 10px; border-bottom: 1px solid var(--border); font-family: 'Courier New', monospace; font-size: 12px; display: flex; gap: 12px; }
        .device-log-entry:hover { background: rgba(59, 130, 246, 0.05); }
        .device-log-entry.log-error { background: rgba(244, 63, 94, 0.08); border-left: 3px solid var(--danger); }
        .device-log-entry.log-system { color: var(--muted); }
        .device-log-time { color: var(--muted); min-width: 120px; flex-shrink: 0; }
        .device-log-message { color: var(--text); word-break: break-word; }
        .logs-container { border: 1px solid var(--border); border-radius: 10px; overflow: hidden; }
        .logs-header { padding: 12px; background: var(--panel-alt); border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; }
        .logs-viewport { max-height: 400px; overflow-y: auto; background: #fafafa; }
        .logs-content { min-height: 100px; }
        .view-tabs { 
            display: flex; 
            gap: 0; 
            margin: 12px 0 18px; 
            border-bottom: 2px solid var(--border);
            padding-bottom: 0;
        }
        .view-tab { 
            padding: 12px 24px; 
            border: none;
            border-bottom: 3px solid transparent;
            background: transparent;
            color: var(--muted); 
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            margin-bottom: -2px;
            text-decoration: none;
        }
        .view-tab:hover {
            color: var(--text);
            background: rgba(34,211,238,0.05);
        }
        .view-tab.active { 
            color: var(--accent);
            border-bottom-color: var(--accent);
            font-weight: 700;
        }
        .device-metrics { display:grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap:16px; margin-bottom:16px; }
        .metric-card { background: var(--panel); border: 1px solid var(--border); border-radius: 14px; padding: 16px; }
        .metric-card h4 { font-size: 14px; color: var(--muted); margin-bottom: 12px; text-transform: uppercase; letter-spacing: 0.5px; }
        .metric-value { font-size: 32px; font-weight: 700; margin: 8px 0; }
        .metric-bar-container { background: rgba(255,255,255,0.05); height: 12px; border-radius: 8px; overflow: hidden; margin-top: 8px; }
        .metric-bar { height: 100%; background: linear-gradient(90deg, var(--accent), var(--accent-strong)); transition: width 0.3s ease; }
        .metric-bar.warning { background: linear-gradient(90deg, var(--warning), #f97316); }
        .metric-bar.danger { background: linear-gradient(90deg, var(--danger), #dc2626); }
        .metric-label { color: var(--muted); font-size: 13px; margin-top: 6px; }
        .sparkline { width: 100%; height: 44px; margin-top: 10px; display:block; }
        .chart-grid { display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap:12px; }
        .chart-card { border:1px solid var(--border); border-radius:14px; padding:14px; background: linear-gradient(180deg, #ffffff, #eef3ff); position: relative; }
        .chart-title { display:flex; justify-content:space-between; align-items:flex-end; gap:10px; margin-bottom:10px; }
        .chart-title h4 { margin:0; font-size:16px; color:var(--text); }
        .chart-title small { color:var(--muted); }
        .chart-svg { width:100%; height:170px; display:block; border-radius:12px; background:#f8fafc; border:1px solid var(--border); }
        .chart-container { width:100%; height:250px; position: relative; }
        .chart-controls { display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap; align-items: center; }
        .time-range-select { padding: 6px 12px; border: 1px solid var(--border); background: white; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; transition: all 0.2s; color: var(--text); }
        .time-range-select:hover { border-color: var(--accent); }
        .time-range-select:focus { outline: none; border-color: var(--accent); }
        .export-btn { padding: 6px 16px; border: none; background: var(--success); color: white; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600; transition: all 0.2s; }
        .export-btn:hover { background: #15803d; box-shadow: 0 2px 8px rgba(22, 163, 74, 0.3); }
        .chart-type-selector { display: flex; gap: 4px; border: 1px solid var(--border); border-radius: 6px; overflow: hidden; background: white; }
        .chart-type-btn { padding: 6px 12px; border: none; background: transparent; cursor: pointer; font-size: 13px; font-weight: 500; transition: all 0.2s; }
        .chart-type-btn:hover { background: var(--panel-alt); }
        .chart-type-btn.active { background: var(--accent); color: white; }
        .gauge-stat { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px; border: 1px solid var(--border); border-radius: 12px; background: white; min-height: 180px; }
        .gauge-stat-value { font-size: 48px; font-weight: 700; margin: 8px 0; }
        .gauge-stat-label { font-size: 14px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600; }
        .gauge-stat-unit { font-size: 24px; color: var(--muted); margin-left: 4px; }
        .gauge-row { display:grid; grid-template-columns: repeat(auto-fit, minmax(220px,1fr)); gap:12px; }
        .gauge-card { border:1px solid var(--border); border-radius:14px; padding:14px; background:#ffffff; display:flex; flex-direction:column; gap:10px; }
        .gauge-head { display:flex; justify-content:space-between; gap:12px; align-items:center; }
        .gauge-head h5 { margin:0; font-size:13px; color:var(--muted); text-transform:uppercase; letter-spacing:0.05em; }
        .gauge-head strong { font-size:16px; color:var(--text); }
        .gauge-svg { width:100%; height:120px; display:block; }
        .stacked-bar { height:12px; border-radius:8px; overflow:hidden; background: rgba(255,255,255,0.05); border:1px solid var(--border); display:flex; }
        .stacked-seg { height:100%; }
        .stacked-used { background: linear-gradient(90deg, var(--accent), var(--accent-strong)); }
        .stacked-free { background: rgba(148,163,184,0.18); }
        .analytics-grid { display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap:16px; }
        @media (max-width: 1200px) {
            .analytics-grid { grid-template-columns: 1fr; }
        }
        @media (max-width: 980px) {
            .chart-grid { grid-template-columns: 1fr; }
        }
        .service-status { display: flex; align-items: center; gap: 12px; padding: 12px; background: rgba(34,211,238,0.08); border-radius: 10px; }
        .service-status .dot { width: 12px; height: 12px; }
        .service-name { font-weight: 600; font-size: 16px; }
        .service-info { color: var(--muted); font-size: 13px; }
        .hidden { display:none; }
        @media (max-width: 1100px) {
            .grid { grid-template-columns: 1fr; }
            .energy-grid { grid-template-columns: repeat(2, minmax(0,1fr)); }
            .predict-grid { grid-template-columns: repeat(2, minmax(0,1fr)); }
        }
        @media (max-width: 720px) {
            .energy-grid { grid-template-columns: repeat(2, minmax(0,1fr)); }
            .predict-grid { grid-template-columns: 1fr; }
            .status-row { grid-template-columns: 1fr; }
        }
        
        /* Progress bar styles */
        .progress-bar-container { width: 100%; height: 8px; background: var(--border); border-radius: 4px; overflow: hidden; position: relative; margin-top: 8px; }
        .progress-bar-fill { height: 100%; background: linear-gradient(90deg, var(--accent), var(--success)); transition: width 0.3s ease; border-radius: 4px; }
        
        /* Deploy button styles */
        .mini-btn.primary { background: var(--accent); color: white; border-color: var(--accent); }
        .mini-btn.primary:hover { background: #059669; border-color: #059669; }
        .mini-btn.primary:disabled { background: var(--border); border-color: var(--border); color: var(--muted); cursor: not-allowed; }
        
        /* Telemetry grid */
        .telemetry-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 12px; margin-top: 12px; }
        .metric-card { border: 1px solid var(--border); border-radius: 12px; padding: 14px; background: #ffffff; }
        .metric-card h4 { font-size: 12px; color: var(--muted); margin: 0 0 8px 0; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; }
        .metric-value { font-size: 24px; font-weight: 700; color: var(--text); margin: 0; }
    </style>
</head>
<body>
    <div class="shell">
        <header class="page-title">
            <h1>IoT ML Energy Manager</h1>
            <p>Deploy ML models and monitor device energy & performance.</p>
        </header>

        <div class="view-tabs" id="view_tabs">
            <button class="view-tab" data-view="deployment">Deployment</button>
            <button class="view-tab" data-view="monitoring">Monitoring</button>
            <button class="view-tab" data-view="analytics">Model Analytics</button>
        </div>

        <!-- Hidden fields to store current device endpoint/IP and UUID for polling -->
        <input type="hidden" id="bbb_ip" value="">
        <input type="hidden" id="device_uuid" value="">

        {% include 'deployment.html' %}
        {% include 'monitoring.html' %}
        {% include 'analytics.html' %}

    </div> <!-- end shell -->
    <script>
        let allModels = [];
        let selectedModel = null;
        let energyThresholds = null;  // Cache for energy thresholds from API
        let currentFilter = 'all';
        let statusInterval = null;
        let balenaDevices = [];
        let balenaFleets = [];
        let balenaDevicesLoaded = false;
        let balenaFleetsLoaded = false;
        let devicesLoadPromise = null;
        let fleetsLoadPromise = null;
        const MAX_METRIC_POINTS = 120;
        let deviceMetricsHistory = [];
        let lastDeviceMetrics = null;
        let metricsPollInterval = null;
        let deployMetricsPollInterval = null;
        let logPollInterval = null;
        let activeMonitorTab = 'trends';

        let recommendedSet = new Set();
        let selectedDeviceBudget = null;
        const deviceStatusCache = {};
        let lastDeploymentByDevice = {};
        const DEFAULT_BUDGET_MWH = 100; // Default energy budget in mWh
        const INITIAL_VIEW = "{{ initial_view|default('deployment') }}";
        const DEVICE_ENERGY_BUDGETS = {
            'beaglebone': 80,
            'raspberry-pi-4': 150,
            'raspberry-pi-5': 180,
            'raspberry-pi-zero': 60,
            'jetson-nano': 250,
            'arduino': 30,
            'esp32': 40,
            'default': 100
        };

        // Monitoring chart globals
        let monitoringCharts = {};
        let selectedTimeRange = '5m'; // Default 5 minutes
        let chartViewMode = 'gauges'; // 'gauges', 'trends', 'distribution'
        let chartsInitialized = false;

        function setActiveView(view) {
            console.log('Switching to view:', view);
            
            const deploymentView = document.getElementById('deployment_view');
            const monitoringView = document.getElementById('monitoring_view');
            const analyticsView = document.getElementById('analytics_view');
            const viewTabs = document.getElementById('view_tabs');

            console.log('Found elements:', {
                deploymentView: !!deploymentView,
                monitoringView: !!monitoringView,
                analyticsView: !!analyticsView,
                viewTabs: !!viewTabs
            });

            if (viewTabs) {
                viewTabs.querySelectorAll('.view-tab').forEach(el => {
                    const v = el.dataset.view;
                    el.classList.toggle('active', v === view);
                });
            }
            if (deploymentView) deploymentView.classList.toggle('hidden', view !== 'deployment');
            if (monitoringView) monitoringView.classList.toggle('hidden', view !== 'monitoring');
            if (analyticsView) analyticsView.classList.toggle('hidden', view !== 'analytics');

            if (view === 'deployment') {
                console.log('Deployment view activated');
                loadDeploymentLogs();
                
                // Ensure fleets and devices are populated
                if (balenaFleetsLoaded) {
                    populateFleetSelector();
                }
                if (balenaDevicesLoaded) {
                    populateDeviceSelectors(balenaDevices);
                }
            } else if (view === 'monitoring') {
                startMetricsPolling();
                renderMonitoringTab('trends');
            } else {
                stopMetricsPolling();
            }
            
            if (view === 'analytics') {
                loadModelAnalytics();
            }
            
            console.log('View switched to:', view);
        }

        function initViewRouting() {
            const path = window.location.pathname;
            let initial = INITIAL_VIEW || 'deployment';
            if (path.includes('/monitoring')) {
                initial = 'monitoring';
            } else if (path.includes('/deployment')) {
                initial = 'deployment';
            } else if (path.includes('/analytics')) {
                initial = 'analytics';
            }
            setActiveView(initial);
            
            // Setup tab click handlers
            const tabs = document.querySelectorAll('.view-tab');
            console.log('Setting up tab click handlers for', tabs.length, 'tabs');
            tabs.forEach(tab => {
                console.log('  - Tab:', tab.dataset.view, tab.textContent.trim());
                tab.addEventListener('click', () => {
                    const view = tab.dataset.view;
                    console.log('Tab clicked:', view);
                    if (view) {
                        setActiveView(view);
                        window.history.pushState({}, '', `/${view}`);
                    }
                });
            });
        }

        window.addEventListener('DOMContentLoaded', () => {
            // Load deployment logs from server on page load
            loadDeploymentLogs();
            initViewRouting();

            const monitorRefreshBtn = document.getElementById('monitor_refresh_btn');
            if (monitorRefreshBtn) {
                monitorRefreshBtn.addEventListener('click', () => refreshDeviceMetrics());
            }

            renderMonitoringTab('trends');

            const filterSelect = document.getElementById('filter_select');
            if (filterSelect) {
                filterSelect.addEventListener('change', (evt) => {
                    setFilterActive(evt.target.value);
                    filterModels(evt.target.value);
                });
            }

            const searchInput = document.getElementById('search_input');
            if (searchInput) {
                // Real-time search as user types
                searchInput.addEventListener('input', () => {
                    renderModelList();
                });
                
                // Also trigger on Enter key
                searchInput.addEventListener('keypress', (evt) => {
                    if (evt.key === 'Enter') {
                        evt.preventDefault();
                        renderModelList();
                    }
                });
            }

            const modelGrid = document.getElementById('model_grid');
            if (modelGrid) {
                modelGrid.addEventListener('click', (evt) => {
                    // Handle deploy button click
                    const deployBtn = evt.target.closest('[data-deploy]');
                    if (deployBtn) {
                        evt.stopPropagation();
                        const modelName = decodeURIComponent(deployBtn.dataset.deploy);
                        deployModelToDevices(modelName);
                        return;
                    }
                    
                    // Handle download button click
                    const downloadBtn = evt.target.closest('[data-download]');
                    if (downloadBtn) {
                        evt.stopPropagation();
                        const modelName = decodeURIComponent(downloadBtn.dataset.download);
                        handleDownload(modelName, downloadBtn);
                        return;
                    }
                    
                    // Removed: Model selection on click - use Deploy buttons only
                });
            }

            const balenaRefreshBtn = document.getElementById('balena_refresh_btn');
            if (balenaRefreshBtn) {
                balenaRefreshBtn.addEventListener('click', () => {
                    balenaDevicesLoaded = false; // Clear cache
                    loadBalenaDevices(true, true); // Force reload
                });
            }

            const balenaAppFilter = document.getElementById('balena_app_filter');
            if (balenaAppFilter) {
                balenaAppFilter.addEventListener('change', () => {
                    balenaDevicesLoaded = false; // Clear cache when filter changes
                    loadBalenaDevices(false, true);
                });
            }

            const monitorDeviceSelector = document.getElementById('monitor_device_selector');
            if (monitorDeviceSelector) {
                monitorDeviceSelector.addEventListener('change', (e) => {
                    const selectedOption = e.target.selectedOptions[0];
                    const selectedIp = selectedOption?.value || '';
                    const selectedUuid = selectedOption?.dataset?.uuid || '';
                    
                    if (selectedIp) {
                        document.getElementById('bbb_ip').value = selectedIp;
                        document.getElementById('device_uuid').value = selectedUuid;
                        refreshDeviceMetrics({ silent: false });
                    }
                });
            }

            const analyticsRefreshBtn = document.getElementById('analytics_refresh_btn');
            if (analyticsRefreshBtn) {
                analyticsRefreshBtn.addEventListener('click', () => loadModelAnalytics());
            }

            const logsRefreshBtn = document.getElementById('logs_refresh_btn');
            if (logsRefreshBtn) {
                logsRefreshBtn.addEventListener('click', () => loadDeploymentLogs());
            }

            const predictEnergyBtn = document.getElementById('predict_energy_btn');
            if (predictEnergyBtn) {
                predictEnergyBtn.addEventListener('click', () => predictEnergy());
            }

            const commonModelSelector = document.getElementById('common_model_selector');
            if (commonModelSelector) {
                commonModelSelector.addEventListener('change', (e) => autoFillModelMetrics(e.target.value));
            }

            loadInitialData();
            startStatusPolling();
            renderSelectionPreview();
            updateFilterCount(0);
            renderEnergyMetrics(null);
            
            // Load Balena data once on page load (parallel)
            Promise.all([loadBalenaFleets(), loadBalenaDevices()]).then(() => {
                console.log('Balena data loaded');
            }).catch(err => console.error('Failed to load Balena data:', err));
        });

        async function loadInitialData() {
            showLoading();
            try {
                await Promise.all([loadRecommendations(), loadAllModels()]);
            } catch (err) {
                console.error(err);
            }
        }

        async function loadRecommendations() {
            try {
                const resp = await fetch(`/api/models/recommended?device_type=BBB&max_energy=${DEFAULT_BUDGET_MWH}`);
                const data = await resp.json();
                if (data.success) {
                    const names = (data.recommendations || []).map(m => m.name);
                    recommendedSet = new Set(names);
                    applyRecommendationsToModels();
                    displayStats(data.stats);
                    showAlert('success', 'Loaded recommended models.');
                } else {
                    updateFilterCount(allModels.length || 0);
                    showAlert('error', data.error || 'Unable to load recommendations.');
                }
            } catch (err) {
                updateFilterCount(allModels.length || 0);
                showAlert('error', 'Failed to load data: ' + err);
            }
        }

        async function loadAllModels() {
            try {
                // Get selected device to determine which models to recommend
                const selectedDevices = Array.from(document.querySelectorAll('.device-checkbox:checked'));
                
                // Only load recommendations if a device is selected
                if (selectedDevices.length === 0) {
                    // No device selected - load all models without recommendations
                    const resp = await fetch('/api/models/all');
                    const data = await resp.json();
                    if (data.success) {
                        allModels = data.models || [];
                        recommendedSet = new Set();  // Empty set - no recommendations
                        applyRecommendationsToModels();
                        selectedModel = null;
                        displayStats(data.stats || null);
                        setFilterActive('all');
                        filterModels('all');
                        renderSelectionPreview();
                        const deployBtn = document.getElementById('deploy_btn');
                        if (deployBtn) deployBtn.disabled = true;
                        updateFilterCount(allModels.length || 0);
                        showAlert('info', `Loaded ${allModels.length} models. Select a device to see recommendations.`);
                    } else {
                        updateFilterCount(allModels.length || 0);
                        showAlert('error', data.error || 'Unable to load model list.');
                    }
                    return;
                }
                
                // Device is selected - determine device type
                const deviceCheckbox = selectedDevices[0];
                const deviceNameLower = (deviceCheckbox.dataset.name || '').toLowerCase();
                let deviceType = 'jetson_nano';  // Default
                
                // Determine device type based on name
                if (deviceNameLower.includes('raspberry') || deviceNameLower.includes('rpi')) {
                    deviceType = 'raspberry_pi5';
                } else if (deviceNameLower.includes('jetson')) {
                    deviceType = 'jetson_nano';
                } else if (deviceNameLower.includes('beagle')) {
                    deviceType = 'beaglebone';
                }
                
                const resp = await fetch('/api/models/all');
                const data = await resp.json();
                if (data.success) {
                    allModels = data.models || [];
                    
                    // Load recommended models based on device type and mark them
                    try {
                        const recResp = await fetch(`/api/models/recommended?device=${deviceType}&limit=50`);
                        const recData = await recResp.json();
                        
                        if (recData.success && recData.models) {
                            // Build set of recommended model names from all categories
                            recommendedSet = new Set();
                            
                            // Add excellent models (highest priority)
                            if (recData.models.excellent) {
                                recData.models.excellent.forEach(m => recommendedSet.add(m.name));
                            }
                            
                            // Add good models
                            if (recData.models.good) {
                                recData.models.good.forEach(m => recommendedSet.add(m.name));
                            }
                            
                            // Optionally add acceptable models (you can remove this if you want only excellent/good)
                            if (recData.models.acceptable) {
                                recData.models.acceptable.slice(0, 10).forEach(m => recommendedSet.add(m.name));
                            }
                            
                            console.log(`Marked ${recommendedSet.size} models as recommended for ${deviceType}`);
                        }
                    } catch (recErr) {
                        console.warn('Failed to load recommended models:', recErr);
                        recommendedSet = new Set();
                    }
                    
                    applyRecommendationsToModels();
                    selectedModel = null;
                    displayStats(data.stats || null);
                    setFilterActive('all');
                    filterModels('all');
                    renderSelectionPreview();
                    const deployBtn = document.getElementById('deploy_btn');
                    if (deployBtn) deployBtn.disabled = true;
                    updateFilterCount(allModels.length || 0);
                    showAlert('info', `Loaded ${allModels.length} models (${recommendedSet.size} recommended for ${deviceType})`);
                } else {
                    updateFilterCount(allModels.length || 0);
                    showAlert('error', data.error || 'Unable to load model list.');
                }
            } catch (err) {
                updateFilterCount(allModels.length || 0);
                showAlert('error', 'Failed to load data: ' + err);
            }
        }

        function applyRecommendationsToModels() {
            if (!Array.isArray(allModels) || !allModels.length) return;
            allModels = allModels.map(m => ({
                ...m,
                recommended: recommendedSet.has(m.name)
            }));
        }

        function filterModels(type) {
            currentFilter = type;
            renderModelList();
        }

        function isLibraryModel(model) {
            if (!model || typeof model !== 'object') return false;
            if (model.is_library != null) return Boolean(model.is_library);
            if (model.library != null) return Boolean(model.library);
            if (model.source) {
                return String(model.source).toLowerCase().includes('library');
            }
            return false;
        }

        function renderModelList() {
            let filtered = [...allModels];

            // Apply search filter first
            const searchInput = document.getElementById('search_input');
            const searchTerm = searchInput ? searchInput.value.toLowerCase().trim() : '';
            
            if (searchTerm) {
                filtered = filtered.filter(m => {
                    const name = (m.name || '').toLowerCase();
                    return name.includes(searchTerm);
                });
            }

            // Then apply additional filters
            switch (currentFilter) {
                case 'recommended':
                    filtered = filtered.filter(m => m.recommended);
                    break;
                case 'under_50':
                case 'low_energy':
                    filtered = filtered.filter(m => Number(m.energy_mwh) < 50);
                    break;
                case 'under_100':
                    filtered = filtered.filter(m => Number(m.energy_mwh) < 100);
                    break;
                case 'small_size':
                    filtered = filtered.filter(m => Number(m.size_mb) < 30);
                    break;
                default:
                    break;
            }
            if (selectedModel && !filtered.some(m => m.name === selectedModel)) {
                selectedModel = null;
            }
            updateFilterCount(filtered.length);
            displayModels(filtered);
            const deployBtn = document.getElementById('deploy_btn');
            if (deployBtn) deployBtn.disabled = !selectedModel;
            renderSelectionPreview();
        }

        function updateFilterCount(count) {
            const note = document.getElementById('filter_result_note');
            if (!note) return;
            const label = count === 1 ? 'model' : 'models';
            
            // Get current filter name for display
            const filterSelect = document.getElementById('filter_select');
            const filterText = filterSelect ? filterSelect.options[filterSelect.selectedIndex].text : 'All models';
            
            // Check if search is active
            const searchInput = document.getElementById('search_input');
            const searchTerm = searchInput ? searchInput.value.trim() : '';
            
            if (searchTerm) {
                note.textContent = `${count} ${label} (filtered by search & "${filterText}")`;
            } else {
                note.textContent = `${count} ${label} (${filterText})`;
            }
            note.style.color = 'var(--muted)';
            note.style.fontSize = '13px';
            note.style.fontWeight = '500';
        }

        function displayModels(models) {
            const container = document.getElementById('model_grid');
            if (!container) return;
            if (!models || models.length === 0) {
                container.innerHTML = '<div class="loading-state">No models match the current filter.</div>';
                return;
            }
            container.innerHTML = models.map(model => {
                const rawName = model.name || 'Unnamed model';
                const encodedName = encodeURIComponent(rawName);
                const escapedName = escapeHtml(rawName);
                const reason = model.reason ? `<div class="model-reason">${escapeHtml(model.reason)}</div>` : '';
                const recommendedClass = model.recommended ? 'recommended' : '';
                const badge = model.recommended ? '<span class="pill">Recommended</span>' : '';
                const downloadStatus = model.downloaded ? '<span class="status-pill ok">Downloaded</span>' : '<span class="status-pill warn">Not downloaded</span>';
                const downloadBtn = model.downloaded ? '' : `<button class="mini-btn" data-download="${encodedName}">Download</button>`;
                const deployBtn = model.downloaded ? `<button class="mini-btn primary" data-deploy="${encodedName}">Deploy</button>` : '';
                return `
                    <div class="model-item ${recommendedClass}" data-model="${encodedName}">
                        <div class="model-head">
                            <div class="model-name">${escapedName}${badge}</div>
                            <div class="model-actions" style="display: flex; gap: 8px; align-items: center;">
                                ${downloadStatus}
                                ${downloadBtn}
                                ${deployBtn}
                            </div>
                        </div>
                        <div class="model-meta">
                            <span>Energy: <strong>${formatMetric(model.energy_mwh, 2)} mWh</strong></span>
                            <span>Size: <strong>${formatMetric(model.size_mb, 2)} MB</strong></span>
                            <span>Latency: <strong>${formatMetric(model.latency_s, 3)} s</strong></span>
                            <span>Params: <strong>${formatMetric(model.params_m, 2)} M</strong></span>
                        </div>
                        ${reason}
                    </div>
                `;
            }).join('');
        }

        function selectModel(modelName) {
            selectedModel = modelName;
            renderModelList();
            renderSelectionPreview();
            showAlert('info', `Selected ${modelName}`);
        }

        function deployModel() {
            if (!selectedModel) {
                showAlert('error', 'Please select a model before deploying.');
                return;
            }
            const bbbIp = (document.getElementById('bbb_ip').value || '').trim();
            if (!bbbIp) {
                showAlert('error', 'Please enter the device IP before deploying.');
                return;
            }
            const energyBudget = DEFAULT_BUDGET_MWH;
            const modelDetails = getModelByName(selectedModel);
            let forceDeploy = false;
            if (modelDetails && Number(modelDetails.energy_mwh) > energyBudget) {
                const confirmOverride = window.confirm(
                    `This model is estimated at ${modelDetails.energy_mwh} mWh, above the ${energyBudget} mWh budget. Continue anyway?`
                );
                if (!confirmOverride) {
                    showAlert('error', 'Deployment cancelled (over budget).');
                    showDeploymentLog('Deployment cancelled (over budget).', 'error');
                    return;
                }
                forceDeploy = true;
            }
            showAlert('info', 'Deploying model...');
            showDeploymentLog(`Starting deployment: ${selectedModel} -> ${bbbIp}`, 'info');
            if (energyBudget !== null) {
                showDeploymentLog(`Energy budget: ${energyBudget} mWh`, 'info');
            }
            const deployBtn = document.getElementById('deploy_btn');
            if (deployBtn) deployBtn.disabled = true;
            fetch('/api/deploy', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    bbb_ip: bbbIp,
                    model_name: selectedModel,
                    max_energy: energyBudget,
                    force: forceDeploy
                })
            })
            .then(r => r.json())
            .then(data => {
                const deployBtn = document.getElementById('deploy_btn');
                if (deployBtn) deployBtn.disabled = false;
                if (data.success) {
                    showAlert('success', 'Deployment completed.');
                    showDeploymentLog(`Deployment completed: ${selectedModel} (${data.model_info.energy_avg_mwh} mWh)`, 'success');
                    if (data.energy_budget_mwh) {
                        showDeploymentLog(`Monitoring with budget ${data.energy_budget_mwh} mWh`, 'info');
                        // Start energy monitoring (simulated)
                        startEnergyMonitoring(selectedModel, data.energy_budget_mwh);
                    }
                } else {
                    const errorMsg = data.error || 'Unknown error';
                    showAlert('error', 'Deployment failed: ' + errorMsg);
                    showDeploymentLog(`Deployment error: ${errorMsg}`, 'error');
                    
                    // Show helpful message for connection errors
                    if (errorMsg.includes('connect') || errorMsg.includes('Connection') || errorMsg.includes('refused')) {
                        showAlert('warning', 'Check: device online, correct IP, agent running on port 8000.');
                    }
                }
            })
            .catch(err => {
                const deployBtn = document.getElementById('deploy_btn');
                if (deployBtn) deployBtn.disabled = false;
                const errMsg = String(err);
                showAlert('error', 'Unable to connect: ' + errMsg);
                showDeploymentLog('Unable to connect to controller or device.', 'error');
                
                // Additional guidance for common errors
                if (errMsg.includes('Failed to fetch') || errMsg.includes('NetworkError')) {
                    showAlert('warning', 'Network error: check that the controller server is running.');
                }
            });
        }

        function handleDownload(modelName, buttonEl) {
            if (!modelName) return;
            const btn = buttonEl || null;
            const originalText = btn ? btn.textContent : '';
            if (btn) {
                btn.disabled = true;
                btn.textContent = 'Downloading...';
            }
            showAlert('info', `Downloading model ${modelName}...`);
            fetch('/api/models/download', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ model_name: modelName })
            })
                .then(r => r.json())
                .then(data => {
                    if (data.success) {
                        allModels = allModels.map(m => m.name === modelName ? { ...m, downloaded: true } : m);
                        showAlert('success', data.message || `Downloaded ${modelName}`);
                        renderModelList();
                    } else {
                        showAlert('error', data.error || `Download failed: ${modelName}`);
                    }
                })
                .catch(err => showAlert('error', 'Download error: ' + err))
                .finally(() => {
                    if (btn) {
                        btn.disabled = false;
                        btn.textContent = originalText || 'Download';
                    }
                });
        }

        let energyMonitoringInterval = null;
        
        function startEnergyMonitoring(modelName, budget) {
            // Clear existing interval
            if (energyMonitoringInterval) {
                clearInterval(energyMonitoringInterval);
            }
            
            // Update budget display
            document.getElementById('energy_budget_value').textContent = budget.toFixed(1);
            
            // Initial fetch
            updateEnergyMonitoring(modelName, budget);
            
            // Poll every 5 seconds
            energyMonitoringInterval = setInterval(() => {
                updateEnergyMonitoring(modelName, budget);
            }, 5000);
        }
        
        function updateEnergyMonitoring(modelName, budget) {
            fetch(`/api/energy/monitor?model=${encodeURIComponent(modelName)}&duration=60`)
                .then(res => res.json())
                .then(data => {
                    if (data.success && data.readings && data.readings.length > 0) {
                        const stats = data.statistics;
                        const latest = data.readings[data.readings.length - 1];
                        
                        // Update cards
                        document.getElementById('energy_latest_value').textContent = latest.energy_mwh.toFixed(1);
                        document.getElementById('energy_avg_value').textContent = stats.average_mwh.toFixed(1);
                        
                        // Update status badge
                        const statusBadge = document.getElementById('energy_status_badge');
                        if (stats.average_mwh > budget) {
                            statusBadge.textContent = 'Over budget';
                            statusBadge.className = 'badge error';
                        } else {
                            statusBadge.textContent = 'Stable';
                            statusBadge.className = 'badge success';
                        }
                        
                        // Update history list (last 6 readings)
                        const historyList = document.getElementById('energy_history_list');
                        const recentReadings = data.readings.slice(-6).reverse();
                        historyList.innerHTML = recentReadings.map(reading => {
                            const time = new Date(reading.timestamp).toLocaleTimeString('en-US', {
                                hour: '2-digit',
                                minute: '2-digit',
                                second: '2-digit'
                            });
                            const status = reading.status === 'spike' ? ' (spike)' : '';
                            return `<li><span>${time}${status}</span><span>${reading.energy_mwh.toFixed(1)} mWh</span></li>`;
                        }).join('');
                    }
                })
                .catch(err => {
                    console.error('Failed to fetch energy monitoring data:', err);
                });
        }
        
        function stopEnergyMonitoring() {
            if (energyMonitoringInterval) {
                clearInterval(energyMonitoringInterval);
                energyMonitoringInterval = null;
            }
        }

        function predictEnergy() {
            const payload = {
                params_m: Number(document.getElementById('pred_params_m').value),
                gflops: Number(document.getElementById('pred_gflops').value),
                gmacs: Number(document.getElementById('pred_gmacs').value),
                size_mb: Number(document.getElementById('pred_size_mb').value),
                latency_avg_s: Number(document.getElementById('pred_latency').value),
                throughput_iter_per_s: Number(document.getElementById('pred_throughput').value),
            };
            const missing = Object.entries(payload).filter(([_, v]) => Number.isNaN(v));
            if (missing.length) {
                document.getElementById('predict_output').innerHTML = '<span style="color: var(--danger);">Please fill in all numeric fields.</span>';
                return;
            }
            document.getElementById('predict_output').innerHTML = `
                <div class="loading-state" style="padding:8px 0;">
                    <div class="spinner"></div>
                    Predicting energy...
                </div>
            `;
            fetch('/api/predict-energy', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(payload)
            })
            .then(r => r.json())
            .then(data => {
                if (!data.success) {
                    document.getElementById('predict_output').innerHTML = `<span style="color: var(--danger);">Error: ${escapeHtml(data.error || 'Unable to predict')}</span>`;
                    return;
                }
                const pred = data.predictions && data.predictions[0];
                if (!pred) {
                    document.getElementById('predict_output').innerHTML = '<span style="color: var(--danger);">No result returned.</span>';
                    return;
                }
                document.getElementById('predict_output').innerHTML = `
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:6px;">
                        <span class="badge ${pred.prediction_mwh > (data.model_info?.energy_budget_mwh || 0) ? 'over' : 'ok'}">Energy Est.</span>
                        <strong style="font-size:18px;">${formatMetric(pred.prediction_mwh,2)} mWh</strong>
                        <span class="muted">CI: ${formatMetric(pred.ci_lower_mwh,2)} - ${formatMetric(pred.ci_upper_mwh,2)} mWh</span>
                    </div>
                    <div class="muted">Model: ${escapeHtml(pred.model_name || 'N/A')}</div>
                `;
            })
            .catch(err => {
                document.getElementById('predict_output').innerHTML = `<span style="color: var(--danger);">Connection error: ${escapeHtml(err)}</span>`;
            });
        }

        function prefillPredictFromSelection() {
            if (!selectedModel) {
                showAlert('error', 'No model selected to prefill parameters.');
                return;
            }
            const m = getModelByName(selectedModel);
            if (!m) {
                showAlert('error', 'Selected model details not found.');
                return;
            }
            document.getElementById('pred_params_m').value = m.params_m || '';
            document.getElementById('pred_gflops').value = m.gflops || '';
            document.getElementById('pred_size_mb').value = m.size_mb || '';
            document.getElementById('pred_latency').value = m.latency_s || '';
            document.getElementById('pred_throughput').value = m.throughput || '';
            showAlert('info', 'Prefilled available parameters. Add GMACs if missing.');
        }

        function populateFleetSelector() {
            const select = document.getElementById('balena_app_filter');
            if (!select) {
                console.warn('Fleet selector not found');
                return;
            }
            
            select.innerHTML = '<option value="">All fleets</option>';
            balenaFleets.forEach(fleet => {
                const opt = document.createElement('option');
                opt.value = fleet.slug || fleet.name;
                opt.textContent = fleet.name || fleet.slug;
                select.appendChild(opt);
            });
            console.log('✅ Fleet selector populated with', select.options.length, 'options');
        }

        function loadBalenaFleets() {
            // Return cached promise if already loading
            if (fleetsLoadPromise) return fleetsLoadPromise;
            
            // Return immediately if already loaded
            if (balenaFleetsLoaded) return Promise.resolve(balenaFleets);
            
            fleetsLoadPromise = fetch('/api/balena/fleets')
                .then(r => r.json())
                .then(data => {
                    if (data.success && data.fleets) {
                        balenaFleets = data.fleets;
                        balenaFleetsLoaded = true;
                        
                        console.log('✅ Loaded', balenaFleets.length, 'fleets:', balenaFleets.map(f => f.name));
                        
                        populateFleetSelector();
                    }
                    fleetsLoadPromise = null;
                    return balenaFleets;
                })
                .catch(err => {
                    console.error('Failed to load Balena fleets:', err);
                    fleetsLoadPromise = null;
                    throw err;
                });
            
            return fleetsLoadPromise;
        }

        function loadBalenaDevices(showNotification = false, forceReload = false) {
            // Return cached promise if already loading
            if (devicesLoadPromise && !forceReload) return devicesLoadPromise;
            
            // Return cached data if already loaded and not forcing reload
            if (balenaDevicesLoaded && !forceReload) {
                if (showNotification) {
                    showAlert('info', `Using cached ${balenaDevices.length} device(s)`);
                }
                return Promise.resolve(balenaDevices);
            }
            
            console.log('Loading Balena devices...');
            
            const params = new URLSearchParams();
            const appFilter = document.getElementById('balena_app_filter');
            const appValue = appFilter && appFilter.value ? appFilter.value.trim() : '';
            if (appValue) params.set('app', appValue);
            const onlineToggle = document.getElementById('balena_online_only');
            if (onlineToggle && onlineToggle.checked) params.set('online_only', 'true');
            const query = params.toString();
            const url = query ? `/api/balena/devices?${query}` : '/api/balena/devices';
            
            devicesLoadPromise = fetch(url)
                .then(r => r.json())
                .then(data => {
                    if (data.success) {
                        balenaDevices = data.devices || [];
                        balenaDevicesLoaded = true;
                        console.log('Loaded', balenaDevices.length, 'devices');
                        populateDeviceSelectors(balenaDevices);
                        if (showNotification) {
                            showAlert('success', `Loaded ${balenaDevices.length} device(s)`);
                        }
                    } else {
                        showAlert('error', data.error || 'Unable to load Balena devices.');
                    }
                    devicesLoadPromise = null;
                    return balenaDevices;
                })
                .catch(err => {
                    console.error('Failed to load devices:', err);
                    showAlert('error', 'Unable to connect to Balena: ' + err);
                    devicesLoadPromise = null;
                    throw err;
                });
            
            return devicesLoadPromise;
        }

        function populateDeviceSelectors(devices) {
            // Populate deployment device list (checkbox list)
            const deployList = document.getElementById('deploy_device_list');
            if (deployList) {
                // Get currently selected device UUIDs
                const currentSelected = Array.from(deployList.querySelectorAll('.device-checkbox:checked')).map(cb => cb.value);
                
                deployList.innerHTML = '';
                
                if (devices.length === 0) {
                    deployList.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--muted);">No devices found</div>';
                } else {
                    devices.forEach(dev => {
                        if (dev.endpoint || dev.uuid) {
                            const isOnline = dev.is_online === true;
                            const item = document.createElement('div');
                            item.className = 'device-item';
                            
                            // Disable offline devices
                            if (!isOnline) {
                                item.classList.add('disabled');
                            }
                            
                            const isSelected = currentSelected.includes(dev.uuid) && isOnline;
                            if (isSelected) item.classList.add('selected');
                            
                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.className = 'device-checkbox';
                            checkbox.value = dev.uuid || dev.endpoint;
                            checkbox.checked = isSelected;
                            checkbox.disabled = !isOnline; // Disable checkbox for offline devices
                            checkbox.dataset.device = JSON.stringify(dev);
                            
                            const info = document.createElement('div');
                            info.className = 'device-info';
                            
                            const name = document.createElement('div');
                            name.className = 'device-name';
                            const deviceName = dev.device_name || dev.name || 'Unnamed';
                            name.textContent = deviceName;
                            
                            // Add status badge to name
                            const statusBadge = document.createElement('span');
                            statusBadge.className = `device-status-badge ${isOnline ? 'online' : 'offline'}`;
                            statusBadge.textContent = isOnline ? 'ONLINE' : 'OFFLINE';
                            name.appendChild(statusBadge);
                            
                            const details = document.createElement('div');
                            details.className = 'device-details';
                            
                            // Add IP address
                            if (dev.endpoint) {
                                const ipLabel = document.createElement('span');
                                ipLabel.textContent = 'IP: ';
                                ipLabel.style.fontWeight = '500';
                                const ipText = document.createElement('span');
                                ipText.className = 'device-ip';
                                ipText.textContent = dev.endpoint.split('/')[0];
                                details.appendChild(ipLabel);
                                details.appendChild(ipText);
                            }
                            
                            // Show device type
                            if (dev.device_type || dev.app?.name) {
                                if (dev.endpoint) {
                                    details.appendChild(document.createTextNode(' • '));
                                }
                                const typeText = document.createElement('span');
                                typeText.textContent = dev.device_type || dev.app?.name || 'Device';
                                typeText.style.fontWeight = '500';
                                details.appendChild(typeText);
                            }

                            if (dev.is_web_accessible && dev.uuid) {
                                const publicLine = document.createElement('div');
                                publicLine.style.marginTop = '4px';
                                publicLine.style.fontSize = '12px';
                                const publicLabel = document.createElement('span');
                                publicLabel.innerHTML = '🌐 UUID: ';
                                publicLabel.style.fontWeight = '500';
                                const publicLink = document.createElement('a');
                                publicLink.href = `https://${dev.uuid}.balena-devices.com`;
                                publicLink.target = '_blank';
                                publicLink.textContent = `${dev.uuid.substring(0, 12)}...`;
                                publicLink.style.color = 'var(--accent)';
                                publicLink.style.textDecoration = 'none';
                                publicLink.onclick = (e) => e.stopPropagation();
                                publicLine.appendChild(publicLabel);
                                publicLine.appendChild(publicLink);
                                details.appendChild(publicLine);
                            }

                            
                            info.appendChild(name);
                            info.appendChild(details);
                            
                            item.appendChild(checkbox);
                            item.appendChild(info);
                            
                            // Click handler only for online devices
                            if (isOnline) {
                                item.addEventListener('click', () => {
                                    checkbox.checked = !checkbox.checked;
                                    item.classList.toggle('selected', checkbox.checked);
                                    updateSelectedDevicesCount();
                                });
                            } else {
                                // Show tooltip for offline devices
                                item.title = 'Device is offline and cannot be selected';
                            }
                            
                            deployList.appendChild(item);
                        }
                    });
                }
                
                updateSelectedDevicesCount();
                console.log('Populated deploy_device_list with', devices.length, 'devices');
            }
            
            // Populate monitoring device selector
            const monitorSelector = document.getElementById('monitor_device_selector');
            if (monitorSelector) {
                const currentValue = monitorSelector.value;
                monitorSelector.innerHTML = '<option value="">Select a device</option>';
                devices.forEach(dev => {
                    if (dev.endpoint) {
                        const opt = document.createElement('option');
                        opt.value = dev.endpoint;
                        if (dev.uuid) {
                            opt.dataset.uuid = dev.uuid;
                        }
                        
                        let displayText = `${dev.name || 'Device'} (${dev.endpoint})`;
                        if (dev.is_web_accessible && dev.uuid) {
                            displayText += ` [🌐 ${dev.uuid.substring(0, 8)}...]`;
                        }
                        displayText += ` ${dev.is_online ? '🟢' : '🔴'}`;
                        
                        opt.textContent = displayText;
                        monitorSelector.appendChild(opt);
                    }
                });
                if (currentValue) monitorSelector.value = currentValue;
                console.log('Populated monitor_device_selector with', devices.length, 'devices');
            }
        }

        function useBalenaEndpoint(endpoint, name) {
            if (!endpoint) return;
            showBalenaDevicesMessage('', 'info');
            fetch(`/api/status?bbb_ip=${endpoint}`)
                .then(r => r.json())
                .then(data => {
                    if (data.success) {
                        updateDeviceStatus(data.status);
                        showBalenaDevicesMessage('', 'success');
                        const btns = document.querySelectorAll(`.mini-btn[data-endpoint="${encodeURIComponent(endpoint)}"]`);
                        btns.forEach(btn => btn.outerHTML = `<span class="badge ok">Connected</span>`);
                    } else {
                        showBalenaDevicesMessage(data.error || 'Connection failed', 'error');
                    }
                })
                .catch(err => showBalenaDevicesMessage('Unable to connect: ' + err, 'error'));
        }

        function startStatusPolling() {
            if (statusInterval) clearInterval(statusInterval);
            statusInterval = setInterval(() => {
                const bbbIp = (document.getElementById('bbb_ip').value || '').trim();
                const deviceUuid = (document.getElementById('device_uuid').value || '').trim();
                if (!bbbIp && !deviceUuid) return;
                
                const params = new URLSearchParams();
                if (deviceUuid) params.append('device_uuid', deviceUuid);
                if (bbbIp) params.append('bbb_ip', bbbIp);
                
                fetch(`/api/status?${params}`)
                    .then(r => r.json())
                    .then(data => { 
                        if (data.success) {
                            updateDeviceStatus(data.status);
                        } else {
                            // Handle device offline/error gracefully
                            const deviceStatus = document.getElementById('device_status');
                            if (data.device_offline || data.device_timeout) {
                                deviceStatus.querySelector('.status-value').innerHTML = 
                                    `<span class="dot error"></span>Offline`;
                            } else {
                                deviceStatus.querySelector('.status-value').innerHTML = 
                                    `<span class="dot error"></span>Connection error`;
                            }
                        }
                    })
                    .catch(() => {
                        // Network error - show device as offline
                        const deviceStatus = document.getElementById('device_status');
                        if (deviceStatus) {
                            deviceStatus.querySelector('.status-value').innerHTML = 
                                `<span class="dot error"></span>Unavailable`;
                        }
                    });
            }, 5000);
        }

        function updateDeviceStatus(status) {
            const deviceStatus = document.getElementById('device_status');
            const modelStatus = document.getElementById('model_status');
            const normalized = (status && status.status) ? status.status : 'idle';
            const statusClass = ['idle', 'downloading', 'ready', 'running', 'error'].includes(normalized) ? normalized : 'idle';
            deviceStatus.querySelector('.status-value').innerHTML = `<span class="dot ${statusClass}"></span>${normalized.toUpperCase()}`;
            if (status && status.model_name) {
                modelStatus.querySelector('.status-value').textContent = status.model_name;
            } else {
                modelStatus.querySelector('.status-value').textContent = 'No model';
            }
            renderEnergyMetrics(status ? status.energy_metrics : null);
        }

        function displayStats(stats) {
            const mainTotal = document.getElementById('stat_total');
            const main50 = document.getElementById('stat_50');
            const main100 = document.getElementById('stat_100');
            if (!mainTotal || !main50 || !main100) return;
            if (!stats) {
                mainTotal.textContent = '—';
                main50.textContent = '—';
                main100.textContent = '—';
                return;
            }
            mainTotal.textContent = stats.total_models ?? 0;
            main50.textContent = stats.models_under_50mwh ?? 0;
            main100.textContent = stats.models_under_100mwh ?? 0;
        }

        function renderEnergyMetrics(metrics) {
            const budgetEl = document.getElementById('energy_budget_value');
            const latestEl = document.getElementById('energy_latest_value');
            const avgEl = document.getElementById('energy_avg_value');
            const badge = document.getElementById('energy_status_badge');
            const historyEl = document.getElementById('energy_history_list');
            
            if (!budgetEl || !latestEl || !avgEl || !badge || !historyEl) {
                console.warn('Energy metrics elements not found - skipping render');
                return;
            }
            
            if (!metrics) {
                budgetEl.textContent = 'N/A';
                latestEl.textContent = 'N/A';
                avgEl.textContent = 'N/A';
                badge.textContent = 'No data';
                badge.className = 'badge';
                historyEl.innerHTML = '<li><span>No samples yet</span><span></span></li>';
                return;
            }
            const budget = metrics.budget_mwh;
            const latest = metrics.latest_mwh;
            const average = metrics.avg_mwh;
            const history = Array.isArray(metrics.history) ? metrics.history.slice(-6).reverse() : [];
            budgetEl.textContent = budget != null ? formatMetric(budget, 2) : 'N/A';
            latestEl.textContent = latest != null ? formatMetric(latest, 2) : 'N/A';
            avgEl.textContent = average != null ? formatMetric(average, 2) : 'N/A';
            const state = metrics.status === 'over_budget' ? 'over' : 'ok';
            badge.textContent = state === 'over' ? 'Over budget' : 'OK';
            badge.className = `badge ${state === 'over' ? 'over' : 'ok'}`;
            if (!history.length) {
                historyEl.innerHTML = '<li><span>No samples yet</span><span></span></li>';
            } else {
                historyEl.innerHTML = history.map(item => `
                    <li><span>${formatTimestamp(item.timestamp)}</span><span>${formatMetric(item.energy_mwh, 2)} mWh</span></li>
                `).join('');
            }
        }

        function startMetricsPolling() {
            console.log('Started metrics polling');
            
            // Clear existing interval
            if (metricsPollInterval) {
                clearInterval(metricsPollInterval);
            }
            
            // Fetch immediately
            fetchDeviceMetrics();
            
            // Then poll every 5 seconds
            metricsPollInterval = setInterval(() => {
                fetchDeviceMetrics();
            }, 5000);
        }

        function stopMetricsPolling() {
            console.log('Stopped metrics polling');
            
            if (metricsPollInterval) {
                clearInterval(metricsPollInterval);
                metricsPollInterval = null;
            }
        }

        function fetchDeviceMetrics() {
            const bbbIp = document.getElementById('bbb_ip')?.value || 
                         document.getElementById('monitor_device_selector')?.value;
            
            if (!bbbIp) {
                const container = document.getElementById('monitor_content');
                if (container && !container.querySelector('.monitor-card')) {
                    container.innerHTML = '<div class="monitor-card">Please select a device from the dropdown above to view real-time metrics.</div>';
                }
                return;
            }

            const deviceUuid = document.getElementById('device_uuid')?.value || '';
            console.log('Fetching metrics for device:', bbbIp, 'UUID:', deviceUuid);
            
            // Use UUID for cross-network support
            const params = new URLSearchParams();
            if (deviceUuid) params.append('device_uuid', deviceUuid);
            if (bbbIp) params.append('bbb_ip', bbbIp);
            
            fetch(`/api/device/metrics?${params}`)
                .then(res => res.json())
                .then(data => {
                    console.log('API response:', data);
                    
                    if (data.success) {
                        updateDeviceMetrics(data);
                    } else {
                        console.warn('Failed to fetch device metrics:', data.error || 'No metrics data');
                    }
                })
                .catch(err => {
                    console.error('Error fetching device metrics:', err);
                });
        }

        function updateDeviceMetrics(data) {
            const lastUpdate = document.getElementById('monitor_last_update');
            if (lastUpdate) {
                lastUpdate.textContent = new Date().toLocaleTimeString();
            }
            
            // Update service status from agent info
            const serviceDot = document.getElementById('service_dot');
            const serviceState = document.getElementById('service_state');
            const serviceBadge = document.getElementById('service_badge');
            
            const agentStatus = data.agent?.status || 'unknown';
            
            if (serviceDot) {
                serviceDot.className = `dot ${agentStatus === 'ready' || agentStatus === 'running' ? 'ready' : 'idle'}`;
            }
            if (serviceState) serviceState.textContent = agentStatus;
            if (serviceBadge) {
                serviceBadge.textContent = agentStatus.toUpperCase();
                serviceBadge.className = `badge ${agentStatus === 'ready' || agentStatus === 'running' ? 'ok' : ''}`;
            }
            
            // Extract metrics from response (structure: cpu.percent, memory.used_percent, etc)
            const metrics = {
                timestamp: Date.now(),
                cpuPercent: parseFloat(data.cpu?.percent || 0),
                temperatureC: parseFloat(data.temperature_c || 0),
                memUsedPercent: parseFloat(data.memory?.used_percent || 0),
                memUsedGb: parseFloat(data.memory?.used_mb || 0) / 1024,
                memTotalGb: parseFloat(data.memory?.total_mb || 0) / 1024,
                diskUsedPercent: parseFloat(data.storage?.used_percent || 0),
                diskUsedGb: parseFloat(data.storage?.used_gb || 0),
                diskTotalGb: parseFloat(data.storage?.total_gb || 0)
            };
            
            console.log('Received metrics:', metrics);
            
            // Only add to history if we have at least one valid metric
            if (metrics.cpuPercent > 0 || metrics.temperatureC > 0 || metrics.memUsedPercent > 0 || metrics.diskUsedPercent > 0) {
                deviceMetricsHistory.push(metrics);
                
                // Keep only last 120 points
                if (deviceMetricsHistory.length > MAX_METRIC_POINTS) {
                    deviceMetricsHistory.shift();
                }
                
                lastDeviceMetrics = metrics;
                
                // Re-render charts if we have enough data - keep current view mode
                if (deviceMetricsHistory.length > 1) {
                    renderMonitoringTab(chartViewMode);
                }
            } else {
                console.warn('No valid metrics in response. Raw data:', data);
            }
        }

        function refreshDeviceMetrics(options = {}) {
            const bbbIp = document.getElementById('bbb_ip')?.value || 
                         document.getElementById('monitor_device_selector')?.value;
            
            if (!bbbIp) {
                if (!options.silent) {
                    showAlert('error', 'Please select a device first');
                }
                return;
            }

            console.log('Refreshing metrics for device:', bbbIp);
            
            // Update service status
            const serviceDot = document.getElementById('service_dot');
            const serviceState = document.getElementById('service_state');
            const serviceBadge = document.getElementById('service_badge');
            const lastUpdate = document.getElementById('monitor_last_update');
            
            if (serviceDot) serviceDot.className = 'dot downloading';
            if (serviceState) serviceState.textContent = 'checking...';
            if (serviceBadge) {
                serviceBadge.textContent = 'Checking...';
                serviceBadge.className = 'badge';
            }
            
            // Fetch device metrics from correct endpoint
            fetch(`/api/device/metrics?bbb_ip=${encodeURIComponent(bbbIp)}`)
                .then(res => res.json())
                .then(data => {
                    if (data.success && data.metrics) {
                        updateDeviceMetrics(data);
                        
                        if (!options.silent) {
                            showAlert('success', 'Device metrics refreshed');
                        }
                    } else {
                        if (serviceDot) serviceDot.className = 'dot error';
                        if (serviceState) serviceState.textContent = 'offline';
                        if (serviceBadge) {
                            serviceBadge.textContent = 'Offline';
                            serviceBadge.className = 'badge over';
                        }
                        if (!options.silent) {
                            showAlert('error', data.error || 'Failed to connect to device');
                        }
                    }
                })
                .catch(err => {
                    console.error('Failed to refresh metrics:', err);
                    if (serviceDot) serviceDot.className = 'dot error';
                    if (serviceState) serviceState.textContent = 'error';
                    if (serviceBadge) {
                        serviceBadge.textContent = 'Error';
                        serviceBadge.className = 'badge over';
                    }
                    if (!options.silent) {
                        showAlert('error', 'Connection error: ' + err.message);
                    }
                });
        }

        function renderMonitoringTab(tab) {
            const container = document.getElementById('monitor_content');
            if (!container) return;

            const safeTab = tab || chartViewMode;
            const switchingMode = safeTab !== chartViewMode;
            chartViewMode = safeTab;

            const hasHistory = Array.isArray(deviceMetricsHistory) && deviceMetricsHistory.length > 1;
            if (!hasHistory) {
                container.innerHTML = '<div class="monitor-card">No device metrics yet. Select a device to start monitoring.</div>';
                chartsInitialized = false;
                return;
            }

            // If just updating data (not switching modes), only update existing charts
            if (chartsInitialized && !switchingMode) {
                updateMonitoringCharts();
                return;
            }

            // Render controls (time range, export, chart type selector)
            const controlsHtml = `
                <div class="chart-controls">
                    <div class="chart-type-selector">
                        <button class="chart-type-btn ${chartViewMode === 'gauges' ? 'active' : ''}" onclick="switchChartMode('gauges')">Overview</button>
                        <button class="chart-type-btn ${chartViewMode === 'trends' ? 'active' : ''}" onclick="switchChartMode('trends')">Trends</button>
                        <button class="chart-type-btn ${chartViewMode === 'distribution' ? 'active' : ''}" onclick="switchChartMode('distribution')">Distribution</button>
                    </div>
                    <select class="time-range-select" onchange="setTimeRange(this.value)" value="${selectedTimeRange}">
                        <option value="5m" ${selectedTimeRange === '5m' ? 'selected' : ''}>Last 5 minutes</option>
                        <option value="15m" ${selectedTimeRange === '15m' ? 'selected' : ''}>Last 15 minutes</option>
                        <option value="1h" ${selectedTimeRange === '1h' ? 'selected' : ''}>Last 1 hour</option>
                        <option value="6h" ${selectedTimeRange === '6h' ? 'selected' : ''}>Last 6 hours</option>
                        <option value="24h" ${selectedTimeRange === '24h' ? 'selected' : ''}>Last 24 hours</option>
                    </select>
                    <button class="export-btn" onclick="exportMetricsCSV()">
                        Export CSV
                    </button>
                </div>
            `;

            if (safeTab === 'gauges') {
                const latest = deviceMetricsHistory[deviceMetricsHistory.length - 1];
                container.innerHTML = controlsHtml + `
                    <div class="chart-grid">
                        <div class="chart-card">
                            <div class="chart-title"><h4>CPU Usage</h4></div>
                            <div class="chart-container"><canvas id="gauge_cpu"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title"><h4>Temperature</h4></div>
                            <div class="chart-container"><canvas id="gauge_temp"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title"><h4>Memory Used</h4></div>
                            <div class="chart-container"><canvas id="gauge_mem"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title"><h4>Storage Used</h4></div>
                            <div class="chart-container"><canvas id="gauge_disk"></canvas></div>
                        </div>
                    </div>
                `;
                
                // Destroy old charts
                Object.values(monitoringCharts).forEach(chart => chart.destroy());
                monitoringCharts = {};
                
                // Create gauge charts
                createGaugeChart('gauge_cpu', 'CPU Usage', latest.cpuPercent, '%', 0, 100);
                createGaugeChart('gauge_temp', 'Temperature', latest.temperatureC, '°C', 0, 90);
                createGaugeChart('gauge_mem', 'Memory Used', latest.memUsedPercent, '%', 0, 100);
                createGaugeChart('gauge_disk', 'Storage Used', latest.diskUsedPercent, '%', 0, 100);
                chartsInitialized = true;
                return;
            }

            if (safeTab === 'trends') {
                container.innerHTML = controlsHtml + `
                    <div class="chart-grid">
                        <div class="chart-card">
                            <div class="chart-title"><h4>CPU Usage</h4><small>Percentage</small></div>
                            <div class="chart-container"><canvas id="trend_cpu"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title"><h4>Temperature</h4><small>Celsius</small></div>
                            <div class="chart-container"><canvas id="trend_temp"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title"><h4>Memory Usage</h4><small>GB</small></div>
                            <div class="chart-container"><canvas id="trend_mem"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title"><h4>Storage Usage</h4><small>GB</small></div>
                            <div class="chart-container"><canvas id="trend_disk"></canvas></div>
                        </div>
                    </div>
                `;
                
                // Destroy old charts
                Object.values(monitoringCharts).forEach(chart => chart.destroy());
                monitoringCharts = {};
                
                // Create new Chart.js charts
                const filteredData = getFilteredMetrics();
                createLineChart('trend_cpu', 'CPU Usage (%)', filteredData.map(m => m.cpuPercent), filteredData.map(m => m.timestamp), 0, 100, '#3b82f6');
                createLineChart('trend_temp', 'Temperature (°C)', filteredData.map(m => m.temperatureC), filteredData.map(m => m.timestamp), 0, 90, '#f59e0b');
                const maxMem = Math.max(...filteredData.map(m => m.memTotalGb || 8), 8);
                createLineChart('trend_mem', 'Memory Usage (GB)', filteredData.map(m => m.memUsedGb), filteredData.map(m => m.timestamp), 0, maxMem, '#10b981');
                const maxDisk = Math.max(...filteredData.map(m => m.diskTotalGb || 32), 32);
                createLineChart('trend_disk', 'Storage Usage (GB)', filteredData.map(m => m.diskUsedGb), filteredData.map(m => m.timestamp), 0, maxDisk, '#8b5cf6');
                chartsInitialized = true;
                return;
            }

            if (safeTab === 'distribution') {
                container.innerHTML = controlsHtml + `
                    <div class="chart-grid">
                        <div class="chart-card">
                            <div class="chart-title"><h4>CPU Distribution</h4><small>Histogram</small></div>
                            <div class="chart-container"><canvas id="hist_cpu"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title"><h4>Temperature Distribution</h4><small>Histogram</small></div>
                            <div class="chart-container"><canvas id="hist_temp"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title"><h4>Memory Distribution</h4><small>Histogram</small></div>
                            <div class="chart-container"><canvas id="hist_mem"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title"><h4>Storage Distribution</h4><small>Histogram</small></div>
                            <div class="chart-container"><canvas id="hist_disk"></canvas></div>
                        </div>
                    </div>
                `;
                
                // Destroy old charts
                Object.values(monitoringCharts).forEach(chart => chart.destroy());
                monitoringCharts = {};
                
                // Create histograms
                const filteredData = getFilteredMetrics();
                createHistogram('hist_cpu', 'CPU Usage (%)', filteredData.map(m => m.cpuPercent), '#3b82f6');
                createHistogram('hist_temp', 'Temperature (°C)', filteredData.map(m => m.temperatureC), '#f59e0b');
                createHistogram('hist_mem', 'Memory Usage (%)', filteredData.map(m => m.memUsedPercent), '#10b981');
                createHistogram('hist_disk', 'Storage Usage (%)', filteredData.map(m => m.diskUsedPercent), '#8b5cf6');
                chartsInitialized = true;
                return;
            }

            container.innerHTML = '<div class="monitor-card">Select a chart mode to view metrics.</div>';
        }

        function updateMonitoringCharts() {
            if (!chartsInitialized || Object.keys(monitoringCharts).length === 0) return;

            const filteredData = getFilteredMetrics();
            const latest = deviceMetricsHistory[deviceMetricsHistory.length - 1];

            if (chartViewMode === 'gauges') {
                // Update gauge charts with smooth animation
                updateGaugeChart('gauge_cpu', latest.cpuPercent, '%', 0, 100);
                updateGaugeChart('gauge_temp', latest.temperatureC, '°C', 0, 90);
                updateGaugeChart('gauge_mem', latest.memUsedPercent, '%', 0, 100);
                updateGaugeChart('gauge_disk', latest.diskUsedPercent, '%', 0, 100);
            } else if (chartViewMode === 'trends') {
                // Update line charts
                const labels = filteredData.map(m => new Date(m.timestamp).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' }));
                updateLineChart('trend_cpu', filteredData.map(m => m.cpuPercent), labels);
                updateLineChart('trend_temp', filteredData.map(m => m.temperatureC), labels);
                updateLineChart('trend_mem', filteredData.map(m => m.memUsedGb), labels);
                updateLineChart('trend_disk', filteredData.map(m => m.diskUsedGb), labels);
            } else if (chartViewMode === 'distribution') {
                // Update histograms
                updateHistogram('hist_cpu', filteredData.map(m => m.cpuPercent));
                updateHistogram('hist_temp', filteredData.map(m => m.temperatureC));
                updateHistogram('hist_mem', filteredData.map(m => m.memUsedPercent));
                updateHistogram('hist_disk', filteredData.map(m => m.diskUsedPercent));
            }
        }

        function renderGaugeCard(title, value, min, max, unit) {
            const v = (typeof value === 'number') ? value : null;
            const pct = v == null ? 0 : Math.max(0, Math.min(1, (v - min) / ((max - min) || 1)));
            const display = v == null ? 'N/A' : `${formatMetric(v, unit === '%' ? 0 : 1)}${unit}`;
            const stroke = v == null ? 'rgba(148,163,184,0.4)' : 'var(--accent)';
            const dash = Math.round(pct * 283);

            return `
                <div class="gauge-card">
                    <div class="gauge-head"><h5>${escapeHtml(title)}</h5><strong>${escapeHtml(display)}</strong></div>
                    <svg class="gauge-svg" viewBox="0 0 200 120">
                        <path d="M20 110 A80 80 0 0 1 180 110" fill="none" stroke="rgba(148,163,184,0.18)" stroke-width="12" />
                        <path d="M20 110 A80 80 0 0 1 180 110" fill="none" stroke="${stroke}" stroke-width="12" stroke-linecap="round" stroke-dasharray="${dash} 283" />
                    </svg>
                </div>
            `;
        }

        function renderUsedFreeBar(resource) {
            if (!resource || typeof resource.total_bytes !== 'number' || typeof resource.used_bytes !== 'number') {
                return '<div class="muted">N/A</div>';
            }
            const total = resource.total_bytes;
            const used = resource.used_bytes;
            const free = Math.max(0, total - used);
            const usedPct = total ? Math.max(0, Math.min(100, (used / total) * 100)) : 0;
            const freePct = 100 - usedPct;
            const usedGB = used / (1024 * 1024 * 1024);
            const totalGB = total / (1024 * 1024 * 1024);
            return `
                <div class="stacked-bar" aria-label="Used vs free">
                    <div class="stacked-seg stacked-used" style="width:${usedPct.toFixed(2)}%"></div>
                    <div class="stacked-seg stacked-free" style="width:${freePct.toFixed(2)}%"></div>
                </div>
                <div class="inline-stats" style="margin-top: 10px;">
                    <span>Used<strong>${formatMetric(usedGB, 2)} GB</strong></span>
                    <span>Free<strong>${formatMetric(free / (1024 * 1024 * 1024), 2)} GB</strong></span>
                    <span>Total<strong>${formatMetric(totalGB, 2)} GB</strong></span>
                </div>
            `;
        }

        function drawLineChart(svgEl, values, minY, maxY) {
            if (!svgEl) return;
            const series = (Array.isArray(values) ? values : []).filter(v => typeof v === 'number');
            const v = series.slice(-80);
            if (v.length < 2) { svgEl.innerHTML = ''; return; }

            const width = 600;
            const height = 180;
            const padX = 10;
            const padY = 12;
            const min = (typeof minY === 'number') ? minY : Math.min(...v);
            const max = (typeof maxY === 'number') ? maxY : Math.max(...v);
            const span = (max - min) || 1;

            const pts = v.map((val, i) => {
                const x = padX + (i / (v.length - 1)) * (width - padX * 2);
                const y = (height - padY) - ((val - min) / span) * (height - padY * 2);
                return `${x.toFixed(1)},${y.toFixed(1)}`;
            }).join(' ');

            const area = `M ${padX},${height - padY} L ${pts.replace(/\s+/g, ' L ')} L ${width - padX},${height - padY} Z`;

            svgEl.innerHTML = `
                <defs>
                    <linearGradient id="areaFill" x1="0" y1="0" x2="0" y2="1">
                        <stop offset="0%" stop-color="rgba(34,211,238,0.25)" />
                        <stop offset="100%" stop-color="rgba(34,211,238,0)" />
                    </linearGradient>
                </defs>
                <path d="${area}" fill="url(#areaFill)" />
                <polyline fill="none" stroke="var(--accent)" stroke-width="2" points="${pts}" />
            `;
        }

        function drawHistogram(svgEl, values, minX, maxX) {
            if (!svgEl) return;
            const raw = (Array.isArray(values) ? values : []).filter(v => typeof v === 'number');
            const v = raw.slice(-200);
            if (v.length < 3) { svgEl.innerHTML = ''; return; }

            const width = 600;
            const height = 180;
            const bins = 12;
            const min = (typeof minX === 'number') ? minX : Math.min(...v);
            const max = (typeof maxX === 'number') ? maxX : Math.max(...v);
            const span = (max - min) || 1;
            const counts = new Array(bins).fill(0);
            for (const val of v) {
                const idx = Math.max(0, Math.min(bins - 1, Math.floor(((val - min) / span) * bins)));
                counts[idx] += 1;
            }
            const maxCount = Math.max(...counts, 1);

            const gap = 6;
            const barW = (width - gap * (bins + 1)) / bins;
            let bars = '';
            for (let i = 0; i < bins; i++) {
                const barH = (counts[i] / maxCount) * (height - 24);
                const x = gap + i * (barW + gap);
                const y = height - 12 - barH;
                bars += `<rect x="${x.toFixed(1)}" y="${y.toFixed(1)}" width="${barW.toFixed(1)}" height="${barH.toFixed(1)}" rx="6" fill="rgba(34,211,238,0.55)" />`;
            }
            svgEl.innerHTML = bars;
        }

        // New Chart.js functions for Grafana-style monitoring
        function getFilteredMetrics() {
            const now = Date.now();
            const ranges = {
                '5m': 5 * 60 * 1000,
                '15m': 15 * 60 * 1000,
                '1h': 60 * 60 * 1000,
                '6h': 6 * 60 * 60 * 1000,
                '24h': 24 * 60 * 60 * 1000
            };
            const rangeMs = ranges[selectedTimeRange] || ranges['5m'];
            return deviceMetricsHistory.filter(m => (now - m.timestamp) <= rangeMs);
        }

        function setTimeRange(range) {
            selectedTimeRange = range;
            chartsInitialized = false; // Force re-render with new time range
            renderMonitoringTab(chartViewMode);
        }

        function switchChartMode(mode) {
            chartsInitialized = false; // Force re-render when switching modes
            renderMonitoringTab(mode);
        }

        function createLineChart(canvasId, label, data, timestamps, minY, maxY, color) {
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;

            const labels = timestamps.map(t => new Date(t).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' }));

            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: label,
                        data: data,
                        borderColor: color,
                        backgroundColor: color + '20',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0,
                        pointHoverRadius: 6,
                        pointHoverBackgroundColor: color,
                        pointHoverBorderColor: '#fff',
                        pointHoverBorderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 300
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: true,
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: color,
                            borderWidth: 1,
                            padding: 12,
                            displayColors: false,
                            callbacks: {
                                label: function(context) {
                                    return label + ': ' + context.parsed.y.toFixed(2);
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)',
                                drawBorder: false
                            },
                            ticks: {
                                maxRotation: 0,
                                maxTicksLimit: 8,
                                color: '#5b6b80',
                                font: {
                                    size: 11
                                }
                            }
                        },
                        y: {
                            min: minY,
                            max: maxY,
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)',
                                drawBorder: false
                            },
                            ticks: {
                                color: '#5b6b80',
                                font: {
                                    size: 11
                                },
                                callback: function(value) {
                                    return value.toFixed(0);
                                }
                            }
                        }
                    }
                }
            });

            monitoringCharts[canvasId] = chart;
        }

        function createHistogram(canvasId, label, values, color) {
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;

            // Create histogram bins
            const bins = 15;
            const min = Math.min(...values);
            const max = Math.max(...values);
            const range = max - min || 1;
            const binSize = range / bins;
            
            const binCounts = new Array(bins).fill(0);
            const binLabels = [];
            
            for (let i = 0; i < bins; i++) {
                const binStart = min + i * binSize;
                const binEnd = binStart + binSize;
                binLabels.push(binStart.toFixed(1) + '-' + binEnd.toFixed(1));
                
                for (const val of values) {
                    if (val >= binStart && (i === bins - 1 ? val <= binEnd : val < binEnd)) {
                        binCounts[i]++;
                    }
                }
            }

            const chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: binLabels,
                    datasets: [{
                        label: 'Frequency',
                        data: binCounts,
                        backgroundColor: color + '80',
                        borderColor: color,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: true,
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: color,
                            borderWidth: 1,
                            padding: 12,
                            displayColors: false,
                            callbacks: {
                                label: function(context) {
                                    return 'Count: ' + context.parsed.y;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                display: false,
                                drawBorder: false
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45,
                                color: '#5b6b80',
                                font: {
                                    size: 10
                                }
                            }
                        },
                        y: {
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)',
                                drawBorder: false
                            },
                            ticks: {
                                color: '#5b6b80',
                                font: {
                                    size: 11
                                },
                                callback: function(value) {
                                    return Math.floor(value);
                                }
                            }
                        }
                    }
                }
            });

            monitoringCharts[canvasId] = chart;
        }

        function createGaugeChart(canvasId, label, value, unit, minValue, maxValue) {
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;

            // Calculate percentage and color based on value
            const percentage = ((value - minValue) / (maxValue - minValue)) * 100;
            const remaining = 100 - percentage;
            
            // Color gradient based on percentage (green -> yellow -> red)
            let color;
            if (percentage < 50) {
                color = '#10b981'; // Green
            } else if (percentage < 75) {
                color = '#f59e0b'; // Yellow/Orange
            } else {
                color = '#dc2626'; // Red
            }

            const chart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    datasets: [{
                        data: [percentage, remaining],
                        backgroundColor: [color, '#2d3748'],
                        borderWidth: 0,
                        circumference: 270,
                        rotation: 225
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: '75%',
                    animation: {
                        duration: 300,
                        easing: 'easeInOutQuart'
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: false
                        },
                        gaugeText: {
                            value: value,
                            unit: unit,
                            color: color,
                            label: label
                        }
                    }
                },
                plugins: [{
                    id: 'gaugeText',
                    afterDraw: (chart) => {
                        const ctx = chart.ctx;
                        const centerX = (chart.chartArea.left + chart.chartArea.right) / 2;
                        const centerY = (chart.chartArea.top + chart.chartArea.bottom) / 2 + 20;

                        // Get current values from chart options or use initial values
                        const pluginOpts = chart.options.plugins.gaugeText || {};
                        const currentValue = pluginOpts.value !== undefined ? pluginOpts.value : value;
                        const currentUnit = pluginOpts.unit || unit;
                        const currentColor = pluginOpts.color || color;
                        const currentLabel = pluginOpts.label || label;

                        ctx.save();
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        // Draw value
                        ctx.font = 'bold 42px Plus Jakarta Sans';
                        ctx.fillStyle = currentColor;
                        ctx.fillText(currentValue.toFixed(1) + currentUnit, centerX, centerY);
                        
                        // Draw label
                        ctx.font = '14px Plus Jakarta Sans';
                        ctx.fillStyle = '#718096';
                        ctx.fillText(currentLabel, centerX, centerY - 50);
                        
                        ctx.restore();
                    }
                }]
            });

            monitoringCharts[canvasId] = chart;
        }

        function updateGaugeChart(canvasId, value, unit, minValue, maxValue) {
            const chart = monitoringCharts[canvasId];
            if (!chart) return;

            const percentage = ((value - minValue) / (maxValue - minValue)) * 100;
            const remaining = 100 - percentage;
            
            // Update color based on new value
            let color;
            if (percentage < 50) {
                color = '#10b981';
            } else if (percentage < 75) {
                color = '#f59e0b';
            } else {
                color = '#dc2626';
            }

            // Update chart data
            chart.data.datasets[0].data = [percentage, remaining];
            chart.data.datasets[0].backgroundColor = [color, '#2d3748'];
            
            // Update the custom plugin's values
            const currentLabel = chart.options.plugins.gaugeText?.label || '';
            chart.options.plugins.gaugeText = { value, unit, color, label: currentLabel };
            
            chart.update('none'); // Update without animation for smooth refresh
        }

        function updateLineChart(canvasId, data, labels) {
            const chart = monitoringCharts[canvasId];
            if (!chart) return;

            chart.data.labels = labels;
            chart.data.datasets[0].data = data;
            chart.update('none'); // No animation for smooth updates
        }

        function updateHistogram(canvasId, values) {
            const chart = monitoringCharts[canvasId];
            if (!chart) return;

            // Recalculate histogram bins
            const bins = 15;
            const min = Math.min(...values);
            const max = Math.max(...values);
            const range = max - min || 1;
            const binSize = range / bins;
            
            const binCounts = new Array(bins).fill(0);
            
            for (const val of values) {
                const binIndex = Math.min(bins - 1, Math.floor((val - min) / binSize));
                binCounts[binIndex]++;
            }

            chart.data.datasets[0].data = binCounts;
            chart.update('none');
        }

        function exportMetricsCSV() {
            if (!deviceMetricsHistory || deviceMetricsHistory.length === 0) {
                alert('No metrics data to export');
                return;
            }

            const filteredData = getFilteredMetrics();
            
            // CSV header
            let csv = 'Timestamp,CPU %,Temperature °C,Memory %,Storage %\n';
            
            // CSV rows
            filteredData.forEach(m => {
                const timestamp = new Date(m.timestamp).toISOString();
                csv += `${timestamp},${m.cpuPercent},${m.temperatureC},${m.memUsedPercent},${m.diskUsedPercent}\n`;
            });

            // Download
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            const deviceIp = document.getElementById('monitor_device_selector')?.value || 'device';
            const filename = `metrics_${deviceIp}_${selectedTimeRange}_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.csv`;
            
            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function renderParetoPlaceholder() {
            const container = document.getElementById('monitor_content');
            if (!container) return;
            container.innerHTML = '<div class="monitor-card">Model analytics are unavailable.</div>';
        }

        function renderMetricLine(label, value, maxValue, unit = '') {
            const safeMax = maxValue && maxValue > 0 ? maxValue : 1;
            const width = Math.min(100, Math.max(10, Math.round((value / safeMax) * 100)));
            return `
                <div class="metric-line">
                    <span class="label">${escapeHtml(label)}</span>
                    <div class="bar" style="width:${width}%;"></div>
                    <span class="value">${formatMetric(value, 2)} ${unit}</span>
                </div>
            `;
        }

        function renderKpi(label, value) {
            return `
                <div class="kpi">
                    <small>${escapeHtml(label)}</small>
                    <strong>${escapeHtml(value)}</strong>
                </div>
            `;
        }

        function parsePercent(value) {
            const num = Number(String(value || '').replace('%', ''));
            if (Number.isNaN(num)) return 0;
            return Math.min(100, Math.max(0, num));
        }

        function renderSelectionPreview() {
            const preview = document.getElementById('selection_preview');
            if (!preview) return;
            if (!selectedModel) { preview.textContent = 'Select a model to preview metrics and check the energy budget.'; return; }
            const model = getModelByName(selectedModel);
            if (!model) { preview.textContent = 'Model details not found in the dataset.'; return; }
            const parsedBudget = DEFAULT_BUDGET_MWH;
            const energy = Number(model.energy_mwh);
            const exceeding = !Number.isNaN(energy) && energy > parsedBudget;
            preview.innerHTML = `
                <div><strong>${escapeHtml(model.name)}</strong></div>
                <div>Energy: <strong>${formatMetric(model.energy_mwh, 2)} mWh</strong> ${exceeding ? '<span class="risk">Over budget</span>' : ''}</div>
                <div>Budget: <strong>${formatMetric(parsedBudget, 2)} mWh</strong></div>
                <div>Size: <strong>${formatMetric(model.size_mb, 2)} MB</strong> • Latency: <strong>${formatMetric(model.latency_s, 3)} s</strong></div>
            `;
        }

        function getModelByName(name) {
            if (!name) return null;
            return allModels.find(model => model.name === name) || null;
        }

        function showAlert(type, message) {
            const container = document.getElementById('alert_container');
            container.innerHTML = `<div class="alert ${type}">${message}</div>`;
            setTimeout(() => { container.innerHTML = ''; }, 5000);
        }

        function showLoading() {
            const container = document.getElementById('model_grid');
            if (!container) return;
            container.innerHTML = `
                <div class="loading-state">
                    <div class="spinner"></div>
                    Loading data from controller...
                </div>
            `;
        }

        function loadDeploymentLogs() {
            const container = document.getElementById('logs_container');
            if (!container) {
                console.error('logs_container element not found');
                return;
            }
            
            container.innerHTML = '<div class="loading-state"><div class="spinner"></div>Loading logs...</div>';
            
            fetch('/api/logs?limit=50')
                .then(res => {
                    console.log('Logs API response status:', res.status);
                    if (!res.ok) {
                        throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                    }
                    return res.json();
                })
                .then(data => {
                    console.log('Logs data received:', data);
                    
                    if (data.success && data.logs && data.logs.length > 0) {
                        // Logs từ API đã được reverse (mới nhất lên đầu)
                        const logs = data.logs;
                        
                        container.innerHTML = logs.map(logEntry => {
                            const timestamp = new Date(logEntry.timestamp);
                            const timeString = timestamp.toLocaleString('vi-VN', {
                                month: '2-digit',
                                day: '2-digit',
                                hour: '2-digit',
                                minute: '2-digit'
                            });
                            
                            const typeClass = logEntry.type === 'success' ? 'ok' : 
                                            logEntry.type === 'error' ? 'error' : 'info';
                            
                            // Show full message
                            const fullMessage = logEntry.message || 'No message';
                            
                            return `
                                <div class="log-entry ${typeClass}">
                                    <div class="log-header">
                                        <span class="log-time">${escapeHtml(timeString)}</span>
                                        <span class="log-type ${typeClass}">${escapeHtml(logEntry.type || 'info').toUpperCase()}</span>
                                    </div>
                                    <div class="log-message">${escapeHtml(fullMessage)}</div>
                                </div>
                            `;
                        }).join('');
                    } else if (data.success) {
                        container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--muted);">No deployment logs found.</div>';
                    } else {
                        throw new Error(data.error || 'Unknown error');
                    }
                })
                .catch(err => {
                    console.error('Failed to load deployment logs:', err);
                    container.innerHTML = `<div style="text-align: center; padding: 40px; color: var(--danger);">Failed to load logs: ${escapeHtml(err.message)}</div>`;
                });
        }

        async function fetchEnergyThresholds() {
            if (energyThresholds) return energyThresholds;  // Return cached
            
            try {
                const response = await fetch('/api/energy/thresholds');
                const data = await response.json();
                if (data.success && data.thresholds) {
                    energyThresholds = data.thresholds;
                    return energyThresholds;
                }
            } catch (err) {
                console.warn('Failed to fetch thresholds, using defaults:', err);
            }
            
            // Fallback defaults
            return {
                jetson_nano: { p25: 50, p50: 85, p75: 150 },
                raspberry_pi5: { p25: 30, p50: 50, p75: 75 }
            };
        }

        function getEnergyStatus(predicted, deviceKey, thresholds) {
            const device = thresholds[deviceKey] || {};
            const p25 = device.p25 || device.recommended_threshold || 50;
            const p50 = device.p50 || 85;
            const p75 = device.p75 || 150;
            
            if (predicted < p25) {
                return {
                    emoji: '🟢',
                    status: 'EXCELLENT',
                    message: 'Top 25% most energy-efficient',
                    color: '#10b981',
                    deploy: true
                };
            } else if (predicted < p50) {
                return {
                    emoji: '🟡',
                    status: 'GOOD',
                    message: 'Better than average',
                    color: '#f59e0b',
                    deploy: true
                };
            } else if (predicted < p75) {
                return {
                    emoji: '🟠',
                    status: 'ACCEPTABLE',
                    message: 'Higher than average energy',
                    color: '#f97316',
                    deploy: false
                };
            } else {
                return {
                    emoji: '🔴',
                    status: 'HIGH',
                    message: 'Top 25% most energy-intensive',
                    color: '#ef4444',
                    deploy: false
                };
            }
        }

        async function fetchEnergyThresholds() {
            if (energyThresholds) return energyThresholds;  // Return cached
            
            try {
                const response = await fetch('/api/energy/thresholds');
                const data = await response.json();
                if (data.success && data.thresholds) {
                    energyThresholds = data.thresholds;
                    return energyThresholds;
                }
            } catch (err) {
                console.warn('Failed to fetch thresholds, using defaults:', err);
            }
            
            // Fallback defaults
            return {
                jetson_nano: { p25: 50, p50: 85, p75: 150 },
                raspberry_pi5: { p25: 30, p50: 50, p75: 75 }
            };
        }

        function getEnergyStatus(predicted, deviceKey, thresholds) {
            const device = thresholds[deviceKey] || {};
            const p25 = device.p25 || device.recommended_threshold || 50;
            const p50 = device.p50 || 85;
            const p75 = device.p75 || 150;
            
            if (predicted < p25) {
                return {
                    emoji: '🟢',
                    status: 'EXCELLENT',
                    message: 'Top 25% most energy-efficient',
                    color: '#10b981',
                    deploy: true
                };
            } else if (predicted < p50) {
                return {
                    emoji: '🟡',
                    status: 'GOOD',
                    message: 'Better than average',
                    color: '#f59e0b',
                    deploy: true
                };
            } else if (predicted < p75) {
                return {
                    emoji: '🟠',
                    status: 'ACCEPTABLE',
                    message: 'Higher than average energy',
                    color: '#f97316',
                    deploy: false
                };
            } else {
                return {
                    emoji: '🔴',
                    status: 'HIGH',
                    message: 'Top 25% most energy-intensive',
                    color: '#ef4444',
                    deploy: false
                };
            }
        }

        async function predictEnergy() {
            const deviceType = document.getElementById('pred_device_type')?.value || 'jetson_nano';
            const paramsM = parseFloat(document.getElementById('pred_params_m')?.value);
            const gflops = parseFloat(document.getElementById('pred_gflops')?.value);
            const gmacs = parseFloat(document.getElementById('pred_gmacs')?.value);
            const sizeMb = parseFloat(document.getElementById('pred_size_mb')?.value);
            const latency = parseFloat(document.getElementById('pred_latency')?.value);
            const throughput = parseFloat(document.getElementById('pred_throughput')?.value);

            // Validate inputs
            if (isNaN(paramsM) || isNaN(gflops) || isNaN(gmacs) || isNaN(sizeMb) || isNaN(latency) || isNaN(throughput)) {
                showAlert('error', 'Please select a model from the dropdown to auto-fill all fields');
                return;
            }

            const payload = {
                device_type: deviceType,
                params_m: paramsM,
                gflops: gflops,
                gmacs: gmacs,
                size_mb: sizeMb,
                latency_avg_s: latency,
                throughput_iter_per_s: throughput
            };

            const outputDiv = document.getElementById('predict_output');
            outputDiv.innerHTML = '<div class="loading-state"><div class="spinner"></div>Predicting energy...</div>';

            try {
                const response = await fetch('/api/predict-energy', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify([payload])  // Batch format
                });

                const data = await response.json();

                if (data.success && data.predictions && data.predictions.length > 0) {
                    const result = data.predictions[0];
                    const predicted = result.prediction_mwh;
                    const lower = result.ci_lower_mwh || predicted * 0.8;
                    const upper = result.ci_upper_mwh || predicted * 1.2;
                    const modelUsed = result.model_used || 'Unknown';

                    // Fetch thresholds and determine energy status
                    const thresholds = await fetchEnergyThresholds();
                    const deviceKey = deviceType.toLowerCase().includes('jetson') ? 'jetson_nano' : 'raspberry_pi5';
                    const status = getEnergyStatus(predicted, deviceKey, thresholds);
                    
                    const isSuitable = status.deploy;
                    const statusColor = status.color;
                    const statusText = `${status.emoji} ${status.status}: ${status.message}`;

                    outputDiv.innerHTML = `
                        <div style="display: flex; flex-direction: column; gap: 12px;">
                            <div style="text-align: center;">
                                <div style="font-size: 28px; font-weight: 700; color: var(--accent); margin-bottom: 4px;">
                                    ${predicted.toFixed(2)} mWh
                                </div>
                                <div style="font-size: 12px; color: var(--muted);">
                                    Predicted Energy Consumption
                                </div>
                            </div>
                            <div style="background: rgba(59, 130, 246, 0.08); padding: 10px; border-radius: 8px; font-size: 12px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                    <span style="color: var(--muted);">Confidence Interval (95%):</span>
                                    <span style="font-weight: 600;">${lower.toFixed(2)} - ${upper.toFixed(2)} mWh</span>
                                </div>
                                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                    <span style="color: var(--muted);">Model Used:</span>
                                    <span style="font-weight: 600;">${modelUsed}</span>
                                </div>
                                <div style="display: flex; justify-content: space-between; padding-top: 8px; border-top: 1px solid rgba(59, 130, 246, 0.15);">
                                    <span style="color: var(--muted);">Status:</span>
                                    <span style="font-weight: 600; color: ${statusColor};">${statusText}</span>
                                </div>
                            </div>
                            ${isSuitable ? `
                            <button onclick="deployPredictedModel()" style="
                                padding: 10px 16px;
                                background: linear-gradient(135deg, var(--success) 0%, #059669 100%);
                                color: white;
                                border: none;
                                border-radius: 8px;
                                cursor: pointer;
                                font-weight: 600;
                                font-size: 14px;
                                transition: all 0.2s;
                                box-shadow: 0 2px 8px rgba(16, 185, 129, 0.25);
                            " onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(16, 185, 129, 0.35)'" 
                               onmouseout="this.style.transform=''; this.style.boxShadow='0 2px 8px rgba(16, 185, 129, 0.25)'">
                                Deploy to Device
                            </button>
                            ` : ''}
                        </div>
                    `;
                    showAlert('success', `Energy predicted: ${predicted.toFixed(2)} mWh`);
                } else {
                    throw new Error(data.error || 'Failed to predict energy');
                }
            } catch (err) {
                console.error('Energy prediction failed:', err);
                outputDiv.innerHTML = `<div style="color: var(--danger); text-align: center; padding: 20px;">${escapeHtml(err.message)}</div>`;
                showAlert('error', 'Prediction failed: ' + err.message);
            }
        }

        async function deployPredictedModel() {
            console.log('deployPredictedModel called');
            const deviceType = document.getElementById('pred_device_type')?.value || 'jetson_nano';
            const modelName = document.getElementById('popular_model_selector')?.value; // FIXED: correct selector
            const paramsM = document.getElementById('pred_params_m')?.value;
            
            // Get energy from the prediction output div
            const outputDiv = document.getElementById('predict_output');
            const energyText = outputDiv?.textContent || '';
            const energyMatch = energyText.match(/([0-9.]+)\s*mWh/);
            const energyValue = energyMatch ? energyMatch[1] : 'N/A';
            
            console.log('Model:', modelName, 'Device:', deviceType, 'Energy:', energyValue);
            
            if (!modelName) {
                showAlert('warning', 'Please select a model to deploy');
                return;
            }

            // Check if model is available in model_store
            try {
                console.log('Checking model availability for:', modelName);
                const checkResponse = await fetch('/api/models/check', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ model_name: modelName })
                });
                const checkData = await checkResponse.json();
                console.log('Check response:', checkData);
                
                if (checkData.available) {
                    // Model available - proceed to device selection
                    showAlert('info', `Model ${modelName} is available. Proceeding to deployment...`);
                    proceedToDeviceSelection(modelName, deviceType, energyValue, paramsM);
                } else {
                    // Model not available - show download confirmation
                    showAlert('warning', `Model ${modelName} not found. Showing download options...`);
                    showDownloadConfirmation(modelName, deviceType, energyValue, paramsM);
                }
            } catch (err) {
                console.error('Failed to check model availability:', err);
                showAlert('error', 'Failed to check model availability: ' + err.message);
            }
        }
        
        function proceedToDeviceSelection(modelName, deviceType, energyStr, paramsM) {
            console.log('Proceeding to device selection:', modelName);
            
            // Pre-select model in search to make it visible when we switch tabs
            const searchInput = document.getElementById('search_input');
            if (searchInput) {
                searchInput.value = modelName;
            }
            
            // Switch to deployment view (already there, but make sure)
            setActiveView('deployment');
            
            // Scroll to model grid and filter to show the model
            setTimeout(() => {
                renderModelList(); // Refresh with search filter
                
                // Try to find and highlight the model item
                const modelGrid = document.getElementById('model_grid');
                if (modelGrid) {
                    const modelItems = modelGrid.querySelectorAll('.model-item');
                    let found = false;
                    
                    modelItems.forEach(item => {
                        const itemModelName = item.querySelector('.model-name')?.textContent?.trim();
                        // Remove "Recommended" badge text for comparison
                        const cleanName = itemModelName ? itemModelName.replace(/Recommended$/, '').trim() : '';
                        if (cleanName && cleanName === modelName) {
                            item.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            item.style.border = '2px solid var(--accent)';
                            item.style.boxShadow = '0 0 0 4px rgba(59, 130, 246, 0.2)';
                            found = true;
                            
                            // Remove highlight after 3 seconds
                            setTimeout(() => {
                                item.style.border = '';
                                item.style.boxShadow = '';
                            }, 3000);
                        }
                    });
                    
                    if (found) {
                        showAlert('success', `Model "${modelName}" is ready. Select devices and click Deploy.`);
                    } else {
                        showAlert('info', `Search for "${modelName}" to find it in the model list.`);
                    }
                }
            }, 300);
        }
        
        function showDownloadConfirmation(modelName, deviceType, energyStr, paramsM) {
            const model = document.getElementById('download_model');
            const modelTitle = document.getElementById('download_model_title');
            const modelMessage = document.getElementById('download_model_message');
            const confirmBtn = document.getElementById('download_confirm_btn');
            const cancelBtn = document.getElementById('download_cancel_btn');
            
            modelTitle.textContent = 'Model Not Available';
            modelMessage.innerHTML = `
                <p>The model <strong>${escapeHtml(modelName)}</strong> is not yet downloaded to the model store.</p>
                <p style="margin-top: 12px;">Would you like to download it now? This will:</p>
                <ul style="margin: 8px 0 0 20px; color: var(--muted);">
                    <li>Download model from Hugging Face/TIMM</li>
                    <li>Convert to ONNX format (optimized for edge devices)</li>
                    <li>Save to local model store</li>
                </ul>
                <p style="margin-top: 12px; font-size: 13px; color: var(--warning);">⚠️ Download may take 1-3 minutes depending on model size.</p>
            `;
            
            // Show model
            model.classList.add('active');
            
            // Handle confirm
            confirmBtn.onclick = () => {
                model.classList.remove('active');
                downloadModelThenDeploy(modelName, deviceType, energyStr, paramsM);
            };
            
            // Handle cancel
            cancelBtn.onclick = () => {
                model.classList.remove('active');
            };
        }
        
        async function downloadModelThenDeploy(modelName, deviceType, energyStr, paramsM) {
            const model = document.getElementById('download_model');
            const modelTitle = document.getElementById('download_model_title');
            const modelMessage = document.getElementById('download_model_message');
            const progressContainer = document.getElementById('download_progress_container');
            const progressFill = document.getElementById('download_progress_fill');
            const progressStatus = document.getElementById('download_progress_status');
            const modelActions = document.getElementById('download_model_actions');
            
            // Show progress UI
            model.classList.add('active');
            modelTitle.textContent = 'Downloading Model';
            modelMessage.innerHTML = `<p>Downloading and converting <strong>${escapeHtml(modelName)}</strong>...</p>`;
            progressContainer.style.display = 'block';
            modelActions.style.display = 'none';
            
            // Simulate progress (actual download doesn't provide progress yet)
            let progress = 0;
            const progressInterval = setInterval(() => {
                progress += Math.random() * 15;
                if (progress > 90) progress = 90; // Cap at 90% until complete
                progressFill.style.width = progress + '%';
                progressStatus.textContent = `Downloading... ${Math.round(progress)}%`;
            }, 500);
            
            try {
                const response = await fetch('/api/models/download', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ model_name: modelName })
                });
                const data = await response.json();
                
                clearInterval(progressInterval);
                
                if (data.success) {
                    // Complete progress
                    progressFill.style.width = '100%';
                    progressStatus.textContent = 'Download complete!';
                    progressStatus.style.color = 'var(--success)';
                    
                    // Reload models list to include newly downloaded model
                    console.log('Reloading models list after download...');
                    await loadAllModels();
                    
                    setTimeout(() => {
                        model.classList.remove('active');
                        progressContainer.style.display = 'none';
                        modelActions.style.display = 'flex';
                        progressFill.style.width = '0%';
                        progressStatus.textContent = '';
                        progressStatus.style.color = '';
                        
                        showAlert('success', `Model ${modelName} downloaded successfully (${data.size_mb}MB)`);
                        proceedToDeviceSelection(modelName, deviceType, energyStr, paramsM);
                    }, 1500);
                } else {
                    throw new Error(data.error || 'Download failed');
                }
            } catch (err) {
                clearInterval(progressInterval);
                progressStatus.textContent = 'Download failed: ' + err.message;
                progressStatus.style.color = 'var(--danger)';
                
                setTimeout(() => {
                    model.classList.remove('active');
                    progressContainer.style.display = 'none';
                    modelActions.style.display = 'flex';
                    progressFill.style.width = '0%';
                    progressStatus.textContent = '';
                    progressStatus.style.color = '';
                }, 3000);
                
                showAlert('error', 'Download failed: ' + err.message);
            }
        }

        function autoFillModelMetrics(modelKey) {
            // Model metadata mapping (approximations based on typical configurations)
            const modelData = {
                'mobilenet_v2': { params: 3.5, gflops: 0.3, gmacs: 0.15, size: 14.0, latency: 0.025, throughput: 40 },
                'mobilenet_v3_small': { params: 2.5, gflops: 0.06, gmacs: 0.03, size: 9.8, latency: 0.012, throughput: 83 },
                'shufflenet_v2': { params: 2.3, gflops: 0.15, gmacs: 0.075, size: 9.2, latency: 0.018, throughput: 55 },
                'squeezenet': { params: 1.2, gflops: 0.82, gmacs: 0.41, size: 4.8, latency: 0.015, throughput: 66 },
                
                'resnet18': { params: 11.7, gflops: 1.82, gmacs: 0.91, size: 46.8, latency: 0.035, throughput: 28 },
                'resnet34': { params: 21.8, gflops: 3.67, gmacs: 1.84, size: 87.2, latency: 0.058, throughput: 17 },
                'efficientnet_b0': { params: 5.3, gflops: 0.39, gmacs: 0.19, size: 21.2, latency: 0.028, throughput: 35 },
                'densenet121': { params: 8.0, gflops: 2.87, gmacs: 1.44, size: 32.0, latency: 0.042, throughput: 23 },
                
                'resnet50': { params: 25.6, gflops: 4.12, gmacs: 2.06, size: 102.4, latency: 0.072, throughput: 13 },
                'resnet101': { params: 44.5, gflops: 7.85, gmacs: 3.93, size: 178.0, latency: 0.125, throughput: 8 },
                'efficientnet_b3': { params: 12.0, gflops: 1.86, gmacs: 0.93, size: 48.0, latency: 0.055, throughput: 18 },
                'vgg16': { params: 138.0, gflops: 15.5, gmacs: 7.75, size: 552.0, latency: 0.185, throughput: 5 },
                
                'yolov5s': { params: 7.2, gflops: 16.5, gmacs: 8.25, size: 28.8, latency: 0.048, throughput: 20 },
                'yolov5m': { params: 21.2, gflops: 49.0, gmacs: 24.5, size: 84.8, latency: 0.095, throughput: 10 },
                'yolov8n': { params: 3.2, gflops: 8.7, gmacs: 4.35, size: 12.8, latency: 0.032, throughput: 31 },
                'yolov8s': { params: 11.2, gflops: 28.6, gmacs: 14.3, size: 44.8, latency: 0.062, throughput: 16 }
            };

            if (!modelKey || !modelData[modelKey]) {
                // Clear fields if no model selected
                document.getElementById('pred_params_m').value = '';
                document.getElementById('pred_gflops').value = '';
                document.getElementById('pred_gmacs').value = '';
                document.getElementById('pred_size_mb').value = '';
                document.getElementById('pred_latency').value = '';
                document.getElementById('pred_throughput').value = '';
                return;
            }

            const data = modelData[modelKey];
            document.getElementById('pred_params_m').value = data.params.toFixed(2);
            document.getElementById('pred_gflops').value = data.gflops.toFixed(2);
            document.getElementById('pred_gmacs').value = data.gmacs.toFixed(2);
            document.getElementById('pred_size_mb').value = data.size.toFixed(2);
            document.getElementById('pred_latency').value = data.latency.toFixed(4);
            document.getElementById('pred_throughput').value = data.throughput.toFixed(2);
        }

        function showDeploymentLog(message, level = 'info') {
            const placeholder = document.getElementById('deployment_log_placeholder');
            if (placeholder) placeholder.style.display = 'none';
            const log = document.getElementById('deployment_log');
            if (!log) {
                console.warn('deployment_log element not found');
                return;
            }
            const entry = document.createElement('li');
            entry.className = `timeline-entry ${level}`;
            entry.innerHTML = `
                <span class="timeline-dot"></span>
                <div>
                    <p class="timeline-time">${new Date().toLocaleTimeString()}</p>
                    <p class="timeline-text">${message}</p>
                </div>
            `;
            log.appendChild(entry);
            const wrapper = document.getElementById('deployment_log_wrapper');
            wrapper.scrollTop = wrapper.scrollHeight;
        }

        function setFilterActive(filter) {
            const select = document.getElementById('filter_select');
            if (select) {
                select.value = filter;
            }
        }

        function formatTimestamp(value) {
            if (!value) return '--';
            const date = new Date(value);
            if (Number.isNaN(date.getTime())) return escapeHtml(String(value));
            return date.toLocaleTimeString();
        }

        function escapeHtml(value = '') {
            return String(value)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function formatMetric(value, digits = 2) {
            if (value === undefined || value === null || value === '') return '—';
            const num = Number(value);
            if (Number.isNaN(num)) return escapeHtml(String(value));
            return Number(num.toFixed(digits));
        }

        // ============================================================================
        // MODEL ANALYTICS FUNCTIONS
        // ============================================================================

        function showAnalyticsAlert(msg) {
            const box = document.getElementById('analytics_alert_container');
            if (!box) return;
            
            if (!msg) {
                box.style.display = 'none';
                box.textContent = '';
                return;
            }
            
            // Determine alert type from message content
            let alertClass = 'info';
            if (msg.includes('Failed') || msg.includes('error') || msg.includes('⚠️')) {
                alertClass = 'error';
            } else if (msg.includes('Success') || msg.includes('✓')) {
                alertClass = 'success';
            }
            
            box.className = `alert ${alertClass}`;
            box.textContent = msg;
            box.style.display = 'block';
            
            // Auto-hide success messages after 5 seconds
            if (alertClass === 'success') {
                setTimeout(() => {
                    box.style.display = 'none';
                }, 5000);
            }
        }

        function renderParetoPlaceholder(message = 'Model analytics are unavailable.') {
            const container = document.getElementById('analytics_content');
            if (!container) return;
            container.innerHTML = `<div class="monitor-card">${escapeHtml(message)}</div>`;
        }

        function renderParetoAnalysis(models) {
            const container = document.getElementById('analytics_content');
            if (!container) return;

            const normalized = (Array.isArray(models) ? models : []).map(m => {
                const energy = Number(m.energy_mwh ?? m.energy_avg_mwh ?? m.energy);
                const latency = Number(m.latency_s ?? m.latency ?? m.latency_avg_s);
                const size = Number(m.size_mb ?? m.model_size_mb ?? m.size);
                const throughput = Number(m.throughput ?? m.throughput_iter_per_s ?? m.fps);
                return {
                    model: m.model || m.name || m.model_name || 'Unnamed model',
                    energy_mwh: energy,
                    latency_s: latency,
                    size_mb: size,
                    throughput
                };
            }).filter(m => (
                Number.isFinite(m.energy_mwh) && m.energy_mwh > 0 &&
                Number.isFinite(m.latency_s) && m.latency_s > 0 &&
                Number.isFinite(m.size_mb) && m.size_mb > 0 &&
                Number.isFinite(m.throughput) && m.throughput > 0
            ));

            if (!normalized.length) {
                renderParetoPlaceholder('No valid benchmark data found.');
                return;
            }

            const sortedByEnergy = [...normalized].sort((a, b) => a.energy_mwh - b.energy_mwh);
            const paretoFrontier = [];
            for (const model of sortedByEnergy) {
                const isDominated = sortedByEnergy.some(other =>
                    (other.energy_mwh <= model.energy_mwh && other.latency_s <= model.latency_s) &&
                    (other.energy_mwh < model.energy_mwh || other.latency_s < model.latency_s)
                );
                if (!isDominated) paretoFrontier.push(model);
            }

            const topEfficient = sortedByEnergy.slice(0, 15);
            const topCompact = [...normalized].sort((a, b) => a.size_mb - b.size_mb).slice(0, 15);
            const topEfficiencyModels = normalized
                .map(m => ({ ...m, efficiency: m.throughput / m.energy_mwh }))
                .filter(m => Number.isFinite(m.efficiency) && m.efficiency > 0)
                .sort((a, b) => b.efficiency - a.efficiency)
                .slice(0, 10);

            const maxEnergy = Math.max(...topEfficient.map(m => m.energy_mwh), 1);
            const maxLatency = Math.max(...topEfficient.map(m => m.latency_s), 1);
            const maxSize = Math.max(...topCompact.map(m => m.size_mb), 1);
            const maxEff = Math.max(...topEfficiencyModels.map(m => m.efficiency), 1);

            const stats = {
                total: normalized.length,
                avgEnergy: normalized.reduce((s, m) => s + m.energy_mwh, 0) / normalized.length,
                avgLatency: normalized.reduce((s, m) => s + m.latency_s, 0) / normalized.length,
                avgSize: normalized.reduce((s, m) => s + m.size_mb, 0) / normalized.length,
                minEnergy: Math.min(...normalized.map(m => m.energy_mwh)),
                maxEnergy: Math.max(...normalized.map(m => m.energy_mwh))
            };

            container.innerHTML = `
                <div class="monitor-card">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                        <h4>Energy vs Latency (Pareto Frontier)</h4>
                        <span class="badge ok" style="font-size: 11px;">${paretoFrontier.length} optimal</span>
                    </div>
                    <small style="color: var(--accent); font-weight: 600;">Models on the Pareto frontier (optimal energy + latency trade-off)</small>
                    <div class="metric-list" style="max-height: 420px; overflow-y: auto;">
                        ${topEfficient.map((model, idx) => {
                            const isParetoOptimal = paretoFrontier.some(p => p.model === model.model);
                            const energyWidth = Math.min(100, Math.round((model.energy_mwh / maxEnergy) * 100));
                            const latencyWidth = Math.min(100, Math.round((model.latency_s / maxLatency) * 100));
                            const borderStyle = isParetoOptimal ? 'border-left: 3px solid var(--accent); padding-left: 9px;' : '';
                            const bgStyle = isParetoOptimal ? 'background: rgba(34,211,238,0.06);' : '';
                            return `
                                <div class="metric-line" style="flex-direction:column; align-items:flex-start; margin-bottom: 12px; padding: 8px; border-radius: 8px; ${bgStyle} ${borderStyle}">
                                    <span class="label" style="font-size: 13px; font-weight: ${isParetoOptimal ? '700' : '500'}; display: flex; align-items: center; gap: 6px;">
                                        ${isParetoOptimal ? '⭐' : ''} ${idx + 1}. ${escapeHtml(model.model)}
                                    </span>
                                    <div style="display:flex; align-items:center; gap:8px; width:100%; margin-top: 4px;">
                                        <span style="font-size:11px; color:var(--muted); min-width:60px; font-weight: 600;">Energy</span>
                                        <div class="bar" style="width:${energyWidth}%; background: linear-gradient(90deg, #22d3ee, #0ea5e9);"></div>
                                        <span class="value" style="font-weight: 600;">${model.energy_mwh.toFixed(1)} mWh</span>
                                    </div>
                                    <div style="display:flex; align-items:center; gap:8px; width:100%; margin-top: 2px;">
                                        <span style="font-size:11px; color:var(--muted); min-width:60px; font-weight: 600;">Latency</span>
                                        <div class="bar" style="width:${latencyWidth}%; background: linear-gradient(90deg, #8b5cf6, #a855f7);"></div>
                                        <span class="value" style="font-weight: 600;">${model.latency_s.toFixed(3)} s</span>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                    <div style="margin-top: 12px; padding: 10px 12px; background: linear-gradient(135deg, rgba(34,211,238,0.12), rgba(16,185,129,0.08)); border-radius: 10px; border-left: 3px solid var(--accent); font-size: 12px; color: var(--text); font-weight: 500;">
                        💡 <strong>Pareto Optimal:</strong> These models cannot be improved in both energy and latency simultaneously—any improvement in one metric comes at the cost of the other.
                    </div>
                </div>
                <div class="monitor-card">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                        <h4>Energy vs Size Trade-off</h4>
                        <span class="badge ok" style="font-size: 11px; background: rgba(52,211,153,0.16); color: var(--success);">Top 15</span>
                    </div>
                    <small style="color: var(--success); font-weight: 600;">Smallest models (ideal for memory-constrained devices)</small>
                    <div class="metric-list" style="max-height: 420px; overflow-y: auto;">
                        ${topCompact.map((model, idx) => {
                            const energyWidth = Math.min(100, Math.round((model.energy_mwh / maxEnergy) * 100));
                            const sizeWidth = Math.min(100, Math.round((model.size_mb / maxSize) * 100));
                            return `
                                <div class="metric-line" style="flex-direction:column; align-items:flex-start; margin-bottom: 12px;">
                                    <span class="label" style="font-size: 12px;">
                                        ${idx + 1}. ${escapeHtml(model.model)}
                                    </span>
                                    <div style="display:flex; align-items:center; gap:8px; width:100%;">
                                        <span style="font-size:10px; color:var(--muted); min-width:60px;">Size</span>
                                        <div class="bar" style="width:${sizeWidth}%; background: linear-gradient(90deg, #34d399, #10b981);"></div>
                                        <span class="value">${model.size_mb.toFixed(1)} MB</span>
                                    </div>
                                    <div style="display:flex; align-items:center; gap:8px; width:100%;">
                                        <span style="font-size:10px; color:var(--muted); min-width:60px;">Energy</span>
                                        <div class="bar" style="width:${energyWidth}%; background: linear-gradient(90deg, #22d3ee, #0ea5e9);"></div>
                                        <span class="value">${model.energy_mwh.toFixed(1)} mWh</span>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
                <div class="monitor-card">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                        <h4>Efficiency Ranking</h4>
                        <span class="badge" style="font-size: 11px; background: rgba(251,191,36,0.16); color: var(--warning);">Top 10</span>
                    </div>
                    <small style="color: var(--warning); font-weight: 600;">Models by throughput per energy (best performance/cost ratio)</small>
                    <div class="metric-list">
                        ${topEfficiencyModels.map((model, idx) => {
                            const effWidth = Math.min(100, Math.round((model.efficiency / maxEff) * 100));
                            return `
                                <div class="metric-line">
                                    <span class="label" style="font-size: 12px;">${idx + 1}. ${escapeHtml(model.model)}</span>
                                    <div class="bar" style="width:${effWidth}%; background: linear-gradient(90deg, #fbbf24, #f59e0b);"></div>
                                    <span class="value" style="font-size: 11px;">${model.efficiency.toFixed(2)} iter/mWh</span>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
                <div class="monitor-card">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                        <h4>Summary Statistics</h4>
                        <span class="badge" style="font-size: 11px; background: rgba(59,130,246,0.12); color: var(--accent);">${stats.total} models</span>
                    </div>
                    <small style="color: var(--muted); font-weight: 600;">Complete benchmark dataset overview</small>
                    <div class="metric-list">
                        ${[
                            { label: 'Total Models', value: stats.total, unit: '' },
                            { label: 'Avg Energy', value: stats.avgEnergy, unit: ' mWh' },
                            { label: 'Avg Latency', value: stats.avgLatency, unit: ' s' },
                            { label: 'Avg Size', value: stats.avgSize, unit: ' MB' },
                            { label: 'Min Energy', value: stats.minEnergy, unit: ' mWh' },
                            { label: 'Max Energy', value: stats.maxEnergy, unit: ' mWh' }
                        ].map(stat => {
                            const val = (typeof stat.value === 'number' && !isNaN(stat.value) && isFinite(stat.value)) ? stat.value : 0;
                            return `
                            <div class="metric-line">
                                <span class="label">${stat.label}</span>
                                <span class="value">${val.toFixed(2)}${stat.unit}</span>
                            </div>
                        `;}).join('')}
                    </div>
                </div>
            `;
        }

        function loadModelAnalytics() {
            const container = document.getElementById('analytics_content');
            showAnalyticsAlert('');
            
            // Show loading state
            if (container) {
                container.innerHTML = `
                    <div class="loading-state" style="grid-column: 1 / -1; padding: 60px 20px;">
                        <div class="spinner"></div>
                        <p style="margin-top: 16px; font-size: 15px; color: var(--muted);">Analyzing model benchmarks...</p>
                        <p style="margin-top: 8px; font-size: 13px; color: var(--muted);">Calculating Pareto frontier and efficiency metrics</p>
                    </div>
                `;
            }
            
            fetch('/api/models/all')
                .then(res => res.json())
                .then(data => {
                    if (data.success && data.models) {
                        renderParetoAnalysis(data.models);
                        showAnalyticsAlert(''); // Clear any errors
                    } else {
                        showAnalyticsAlert(data.error || 'Failed to load analytics.');
                        renderParetoPlaceholder();
                    }
                })
                .catch(err => {
                    console.error('Failed to load model analytics:', err);
                    showAnalyticsAlert('⚠️ Failed to load analytics: ' + err);
                    renderParetoPlaceholder('Unable to connect to the server. Please check your connection and try again.');
                });
        }

        // ============================================================================
        // MULTI-DEVICE DEPLOYMENT
        // ============================================================================
        
        let selectedModelForDeploy = null;
        let deploymentInProgress = false;
        
        function updateSelectedDevicesCount() {
            const deployList = document.getElementById('deploy_device_list');
            const countEl = document.getElementById('selected_devices_count');
            if (deployList && countEl) {
                const count = deployList.querySelectorAll('.device-checkbox:checked').length;
                countEl.textContent = count;
            }
        }
        
        function getSelectedDevices() {
            const deployList = document.getElementById('deploy_device_list');
            if (!deployList) return [];
            
            const selectedCheckboxes = Array.from(deployList.querySelectorAll('.device-checkbox:checked'));
            return selectedCheckboxes.map(checkbox => {
                try {
                    return JSON.parse(checkbox.dataset.device);
                } catch (e) {
                    console.error('Failed to parse device data:', e);
                    return { uuid: checkbox.value, endpoint: checkbox.value };
                }
            }).filter(dev => dev !== null);
        }
        
        function updateDeploymentStatus(status, message, progress = null) {
            const statusDot = document.getElementById('deployment_status_dot');
            const statusText = document.getElementById('deployment_status_text');
            const progressBar = document.getElementById('deployment_progress');
            const progressFill = document.getElementById('deployment_progress_bar');
            const progressText = document.getElementById('deployment_progress_text');
            
            if (statusDot) {
                statusDot.className = 'dot';
                if (status === 'idle') statusDot.classList.add('idle');
                else if (status === 'deploying') statusDot.classList.add('loading');
                else if (status === 'success') statusDot.classList.add('online');
                else if (status === 'error') statusDot.classList.add('offline');
            }
            
            if (statusText) statusText.textContent = message;
            
            if (progress !== null && progressBar && progressFill && progressText) {
                progressBar.style.display = 'block';
                progressFill.style.width = `${progress}%`;
                progressText.textContent = `${Math.round(progress)}% complete`;
            } else if (progressBar) {
                progressBar.style.display = 'none';
            }
        }
        
        async function deployModelToDevices(modelName) {
            const selectedDevices = getSelectedDevices();
            
            if (!modelName) {
                showAlert('error', 'Please select a model to deploy');
                return;
            }
            
            if (selectedDevices.length === 0) {
                showAlert('error', 'Please select at least one device');
                return;
            }
            
            if (deploymentInProgress) {
                showAlert('warning', 'Deployment already in progress');
                return;
            }
            
            deploymentInProgress = true;
            selectedModelForDeploy = modelName;
            
            const totalDevices = selectedDevices.length;
            let completedCount = 0;
            let successCount = 0;
            let failedDevices = [];
            
            updateDeploymentStatus('deploying', `Deploying to ${totalDevices} device(s)...`, 0);
            
            try {
                // Deploy to each device sequentially
                for (const device of selectedDevices) {
                    try {
                        console.log(`Deploying ${modelName} to device:`, device);
                        
                        const response = await fetch('/api/balena/deploy', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                model_name: modelName,
                                device_uuid: device.uuid,
                                device_endpoint: device.endpoint,
                                fleet: device.fleet_slug || device.slug
                            })
                        });
                        
                        const result = await response.json();
                        
                        if (result.success) {
                            successCount++;
                            console.log(`✅ Deployed to ${device.device_name || device.uuid}`);
                        } else {
                            failedDevices.push({ device: device.device_name || device.uuid, error: result.error });
                            console.error(`❌ Failed to deploy to ${device.device_name}:`, result.error);
                        }
                        
                    } catch (err) {
                        failedDevices.push({ device: device.device_name || device.uuid, error: err.message });
                        console.error(`❌ Exception deploying to ${device.device_name}:`, err);
                    }
                    
                    completedCount++;
                    const progress = (completedCount / totalDevices) * 100;
                    updateDeploymentStatus('deploying', `Deploying... (${completedCount}/${totalDevices})`, progress);
                }
                
                // Update final status
                if (successCount === totalDevices) {
                    updateDeploymentStatus('success', `Successfully deployed to all ${totalDevices} device(s)`, 100);
                    updateCurrentModel(modelName);
                    showAlert('success', `Model "${modelName}" deployed to ${successCount} device(s)`);
                    loadDeploymentLogs(); // Refresh logs
                } else if (successCount > 0) {
                    updateDeploymentStatus('success', `Deployed to ${successCount}/${totalDevices} device(s)`, 100);
                    updateCurrentModel(modelName);
                    const failedList = failedDevices.map(f => `${f.device}: ${f.error}`).join('; ');
                    showAlert('warning', `Partial success: ${successCount} succeeded, ${failedDevices.length} failed. ${failedList}`);
                    loadDeploymentLogs();
                } else {
                    updateDeploymentStatus('error', 'All deployments failed', 100);
                    const failedList = failedDevices.map(f => `${f.device}: ${f.error}`).join('; ');
                    showAlert('error', `Deployment failed for all devices. ${failedList}`);
                }
                
            } catch (err) {
                console.error('Deployment error:', err);
                updateDeploymentStatus('error', 'Deployment error', 0);
                showAlert('error', `Deployment error: ${err.message}`);
            } finally {
                deploymentInProgress = false;
                
                // Auto-clear progress after 5 seconds
                setTimeout(() => {
                    const progressBar = document.getElementById('deployment_progress');
                    if (progressBar) progressBar.style.display = 'none';
                }, 5000);
            }
        }
        
        function updateCurrentModel(modelName) {
            const modelNameEl = document.getElementById('current_model_name');
            const deployTimeEl = document.getElementById('model_deployment_time');
            
            if (modelNameEl) {
                modelNameEl.textContent = modelName || 'No model';
            }
            
            if (deployTimeEl) {
                const now = new Date();
                deployTimeEl.textContent = `Deployed at ${now.toLocaleTimeString()}`;
            }
            
            // Refresh device model status
            setTimeout(() => refreshDeviceModelStatus(), 1000);
        }
        
        // Device Model Status Functions
        let deviceStatusRefreshInterval = null;
        let cachedDeviceStatuses = {}; // Cache previous status to avoid unnecessary re-renders
        
        async function fetchDeviceModelStatus(device) {
            try {
                // Use UUID if available for cross-network support, fallback to IP
                const deviceIdentifier = device.uuid || device.endpoint;
                
                // Use backend proxy to avoid CORS
                const response = await fetch(`/api/device/status/${deviceIdentifier}`, {
                    method: 'GET',
                    signal: AbortSignal.timeout(10000)
                });
                
                const result = await response.json();
                
                if (result.success && result.data) {
                    return {
                        device: device,
                        status: result.data.status || 'unknown',
                        model_name: result.data.model_name || 'None',
                        inference_active: result.data.inference_active || false,
                        error: result.data.error || null,
                        last_update: result.data.last_update || null
                    };
                } else {
                    return {
                        device: device,
                        status: 'offline',
                        error: result.error || 'Unknown error'
                    };
                }
            } catch (err) {
                return {
                    device: device,
                    status: 'offline',
                    error: err.message
                };
            }
        }
        
        function createDeviceStatusCard(result) {
            const deviceName = result.device.device_name || result.device.name || 'Unknown Device';
            const endpoint = result.device.endpoint || 'N/A';
            const deviceId = result.device.uuid || result.device.endpoint;
            
            let statusBadge, statusIcon, statusColor;
            
            if (result.status === 'running') {
                statusBadge = '<span class="badge ok">RUNNING</span>';
                statusIcon = '🟢';
                statusColor = 'var(--success)';
            } else if (result.status === 'ready') {
                statusBadge = '<span class="badge warning">READY</span>';
                statusIcon = '🟡';
                statusColor = 'var(--warning)';
            } else if (result.status === 'error') {
                statusBadge = '<span class="badge error">ERROR</span>';
                statusIcon = '🔴';
                statusColor = 'var(--error)';
            } else if (result.status === 'offline') {
                statusBadge = '<span class="badge muted">OFFLINE</span>';
                statusIcon = '⚫';
                statusColor = 'var(--muted)';
            } else {
                statusBadge = '<span class="badge muted">UNKNOWN</span>';
                statusIcon = '❓';
                statusColor = 'var(--muted)';
            }
            
            return `
                <div id="device-status-${deviceId}" style="padding: 12px; background: rgba(255,255,255,0.03); border-radius: 8px; border-left: 3px solid ${statusColor};">
                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
                        <div>
                            <div style="font-weight: 600; font-size: 14px; margin-bottom: 4px;">
                                ${statusIcon} ${deviceName}
                            </div>
                            <div style="font-size: 11px; color: var(--muted); font-family: monospace;">
                                ${endpoint}
                            </div>
                        </div>
                        ${statusBadge}
                    </div>
                    <div style="display: grid; grid-template-columns: auto 1fr; gap: 8px 12px; font-size: 12px; color: var(--muted);">
                        <strong style="color: var(--text);">Model:</strong>
                        <span style="font-weight: 600; color: ${result.model_name !== 'None' ? 'var(--accent)' : 'var(--muted)'};">${result.model_name}</span>
                        
                        <strong style="color: var(--text);">Inference:</strong>
                        <span>${result.inference_active ? '✅ Active' : '⏸️ Paused'}</span>
                        
                        ${result.error ? `
                            <strong style="color: var(--error);">Error:</strong>
                            <span style="color: var(--error); font-size: 11px; word-break: break-word;">${result.error.substring(0, 100)}${result.error.length > 100 ? '...' : ''}</span>
                        ` : ''}
                    </div>
                </div>
            `;
        }
        
        function hasStatusChanged(oldStatus, newStatus) {
            if (!oldStatus) return true;
            return oldStatus.status !== newStatus.status ||
                   oldStatus.model_name !== newStatus.model_name ||
                   oldStatus.inference_active !== newStatus.inference_active ||
                   oldStatus.error !== newStatus.error;
        }
        
        async function refreshDeviceModelStatus() {
            // Get all online devices from balenaDevices array
            const onlineDevices = balenaDevices.filter(dev => 
                dev.is_online === true && dev.endpoint
            );
            
            const panel = document.getElementById('device_model_status_panel');
            const statusList = document.getElementById('device_model_status_list');
            
            if (!statusList) return;
            
            // Always show panel if we're in deployment view
            if (panel) panel.style.display = 'block';
            
            if (onlineDevices.length === 0) {
                statusList.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--muted);">No online devices found</div>';
                cachedDeviceStatuses = {};
                return;
            }
            
            // Only show loading on first load
            if (Object.keys(cachedDeviceStatuses).length === 0) {
                statusList.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--muted);"><div class="spinner"></div> Loading device status...</div>';
            }
            
            // Fetch status for all online devices in parallel
            const statusPromises = onlineDevices.map(dev => fetchDeviceModelStatus(dev));
            const results = await Promise.all(statusPromises);
            
            // Check if we need full re-render or just update changed items
            let needsFullRender = Object.keys(cachedDeviceStatuses).length === 0 || 
                                  results.length !== Object.keys(cachedDeviceStatuses).length;
            
            if (needsFullRender) {
                // Full render on first load or device count change
                statusList.innerHTML = results.map(result => createDeviceStatusCard(result)).join('');
                // Update cache
                results.forEach(result => {
                    const deviceId = result.device.uuid || result.device.endpoint;
                    cachedDeviceStatuses[deviceId] = result;
                });
            } else {
                // Incremental update - only update changed devices
                results.forEach(result => {
                    const deviceId = result.device.uuid || result.device.endpoint;
                    const oldStatus = cachedDeviceStatuses[deviceId];
                    
                    if (hasStatusChanged(oldStatus, result)) {
                        const cardElement = document.getElementById(`device-status-${deviceId}`);
                        if (cardElement) {
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = createDeviceStatusCard(result);
                            cardElement.replaceWith(tempDiv.firstElementChild);
                        }
                        cachedDeviceStatuses[deviceId] = result;
                    }
                });
            }
        }
        
        // Auto-refresh device status every 10 seconds when panel is visible
        function startDeviceStatusAutoRefresh() {
            stopDeviceStatusAutoRefresh();
            deviceStatusRefreshInterval = setInterval(() => {
                const panel = document.getElementById('device_model_status_panel');
                if (panel && panel.style.display !== 'none') {
                    refreshDeviceModelStatus();
                }
            }, 10000); // Refresh every 10 seconds
        }
        
        function stopDeviceStatusAutoRefresh() {
            if (deviceStatusRefreshInterval) {
                clearInterval(deviceStatusRefreshInterval);
                deviceStatusRefreshInterval = null;
            }
        }
        
        // Device selection change is handled in populateDeviceSelectors
        document.addEventListener('DOMContentLoaded', () => {
            // Update count on load
            updateSelectedDevicesCount();
            
            // Start auto-refresh for device status
            startDeviceStatusAutoRefresh();
        });

        // ============================================================================
        // END MODEL ANALYTICS
        // ============================================================================
    
    </script>
    
    <!-- Download model -->
    <div id="download_model" class="download-model-overlay">
        <div class="download-model">
            <h3 id="download_model_title">Model Not Available</h3>
            <div id="download_model_message"></div>
            
            <div id="download_progress_container" class="download-progress" style="display: none;">
                <div class="download-progress-bar">
                    <div id="download_progress_fill" class="download-progress-fill" style="width: 0%;"></div>
                </div>
                <div id="download_progress_status" class="download-status"></div>
            </div>
            
            <div id="download_model_actions" class="model-actions">
                <button id="download_cancel_btn" class="btn ghost">Cancel</button>
                <button id="download_confirm_btn" class="btn primary">Download</button>
            </div>
        </div>
    </div>
</body>
</html>
