
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IoT ML Energy Manager</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #f5f7fb;
            --panel: #ffffff;
            --panel-alt: #f2f6ff;
            --border: #e4eaf2;
            --text: #0b1b32;
            --muted: #5b6b80;
            --accent: #3b82f6;
            --accent-strong: #2563eb;
            --danger: #dc2626;
            --warning: #f59e0b;
            --success: #16a34a;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Plus Jakarta Sans', 'Segoe UI', Tahoma, sans-serif;
            background: radial-gradient(circle at 14% 16%, rgba(59,130,246,0.14), transparent 32%), radial-gradient(circle at 82% 10%, rgba(16,185,129,0.14), transparent 28%), linear-gradient(180deg, #f5f7fb 0%, #eef2ff 100%);
            color: var(--text);
            min-height: 100vh;
            line-height: 1.55;
        }
        .shell { max-width: 1600px; margin: 0 auto; padding: 28px 22px 48px; }
        .page-title { text-align: center; margin-bottom: 22px; }
        .page-title h1 { 
            font-size: 28px; 
            font-weight: 800; 
            letter-spacing: 0.6px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            gap: 12px;
            text-shadow: 0 0 20px rgba(34, 211, 238, 0.6), 0 0 40px rgba(34, 211, 238, 0.3);
            animation: titleGlow 3s ease-in-out infinite;
        }
        @keyframes titleGlow {
            0%, 100% { text-shadow: 0 0 20px rgba(34, 211, 238, 0.6), 0 0 40px rgba(34, 211, 238, 0.3); }
            50% { text-shadow: 0 0 30px rgba(34, 211, 238, 0.9), 0 0 60px rgba(34, 211, 238, 0.5), 0 0 80px rgba(34, 211, 238, 0.2); }
        }
        .page-title h1::before {
            content: '';
            display: inline-block;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: radial-gradient(circle, #22d3ee, #0ea5e9);
            box-shadow: 0 0 15px rgba(34, 211, 238, 0.8), 0 0 30px rgba(34, 211, 238, 0.5);
            animation: dotPulse 2s ease-in-out infinite;
        }
        @keyframes dotPulse {
            0%, 100% { box-shadow: 0 0 15px rgba(34, 211, 238, 0.8), 0 0 30px rgba(34, 211, 238, 0.5); transform: scale(1); }
            50% { box-shadow: 0 0 25px rgba(34, 211, 238, 1), 0 0 50px rgba(34, 211, 238, 0.7), 0 0 70px rgba(34, 211, 238, 0.4); transform: scale(1.15); }
        }
        .page-title p { color: var(--muted); margin-top: 6px; }
        .section-lede { display: flex; justify-content: space-between; align-items: flex-start; gap: 16px; flex-wrap: wrap; margin-bottom: 8px; }
        .section-lede h2 { font-size: 22px; }
        .section-lede p { color: var(--muted); line-height: 1.6; max-width: 780px; }
        .chip-row { display: flex; gap: 10px; flex-wrap: wrap; margin: 10px 0; }
        .chip { padding: 6px 12px; border-radius: 999px; background: rgba(34,211,238,0.12); color: var(--accent); font-weight: 600; font-size: 12px; letter-spacing: 0.03em; }
        .filter-bar { display: flex; justify-content: space-between; align-items: center; gap: 12px; flex-wrap: wrap; margin: 8px 0 16px; }
        .filter-note { color: var(--muted); font-size: 12px; }
        .inline-stats { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; color: var(--muted); font-size: 13px; }
        .inline-stats strong { color: var(--text); margin-left: 4px; }
        .grid { display: grid; grid-template-columns: minmax(360px, 420px) 1fr; gap: 16px; }
        .panel { background: linear-gradient(180deg, #ffffff 0%, #f3f7ff 100%); border: 1px solid var(--border); border-radius: 18px; padding: 18px; box-shadow: 0 14px 30px rgba(15,23,42,0.06); margin-bottom: 16px; }
        .panel-header { display: flex; justify-content: space-between; align-items: center; gap: 12px; margin-bottom: 14px; }
        .panel-actions { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
        .panel-header h3 { font-size: 18px; }
        .panel-header .muted { color: var(--muted); font-size: 13px; }
        .form-grid { display: grid; gap: 14px; }
        .form-control label { font-size: 13px; color: var(--muted); display: block; margin-bottom: 6px; }
        .form-control input { width: 100%; padding: 12px; border-radius: 12px; border: 1px solid var(--border); background: #ffffff; color: var(--text); }
        .btn { border: 1px solid transparent; border-radius: 12px; padding: 12px 14px; font-weight: 700; cursor: pointer; transition: all 0.2s; color: var(--text); background: #f2f5fb; }
        .btn.primary { background: linear-gradient(135deg, #3b82f6, #22d3ee); color: #0b1220; border-color: transparent; box-shadow: 0 8px 16px rgba(59, 130, 246, 0.18); }
        .btn.ghost { border-color: var(--border); background: transparent; color: var(--text); }
        .btn.full { width: 100%; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .status-row { display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 10px; }
        .status-block { border: 1px solid var(--border); border-radius: 14px; padding: 12px; background: #ffffff; }
        .status-title { color: var(--muted); font-size: 12px; margin-bottom: 6px; }
        .status-value { font-weight: 700; font-size: 15px; display: flex; align-items: center; gap: 8px; }
        .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-flex; }
        .dot.idle { background: #475569; }
        .dot.downloading { background: var(--warning); animation: pulse 1.4s infinite; }
        .dot.ready { background: var(--success); }
        .dot.running { background: var(--accent); animation: pulse 1.4s infinite; }
        .dot.error { background: var(--danger); }
        @keyframes pulse { 0%,100%{opacity:1;} 50%{opacity:0.5;} }
        .energy-grid { display: grid; grid-template-columns: repeat(4, minmax(0,1fr)); gap: 10px; }
        .energy-card { border: 1px solid var(--border); border-radius: 12px; padding: 10px; background: #ffffff; }
        .energy-card small { color: var(--muted); font-size: 12px; }
        .energy-card .value { font-size: 18px; font-weight: 700; margin-top: 4px; }
        .badge { padding: 6px 10px; border-radius: 999px; font-size: 11px; letter-spacing: 0.05em; font-weight: 700; display: inline-flex; align-items: center; gap: 6px; }
        .badge.ok { background: rgba(52,211,153,0.16); color: var(--success); }
        .badge.over { background: rgba(244,63,94,0.16); color: var(--danger); }
        .history-list { list-style: none; margin-top: 10px; display: flex; flex-direction: column; gap: 6px; color: var(--muted); font-size: 12px; }
        .history-list li { display: flex; justify-content: space-between; border-bottom: 1px dashed var(--border); padding-bottom: 6px; }
        .history-list li:last-child { border-bottom: none; }
        .filter-select { padding: 10px 12px; border-radius: 10px; border: 1px solid var(--border); background: #ffffff; color: var(--text); font-weight: 600; min-width: 190px; }
        .library-filter-bar { display: flex; justify-content: flex-end; align-items: center; gap: 12px; margin: 4px 0 10px; }
        .model-list { margin-top: 14px; display: flex; flex-direction: column; gap: 10px; max-height: 550px; overflow-y: auto; padding-right: 4px; }
        .model-item { border: 1px solid var(--border); border-radius: 14px; padding: 12px; background: #ffffff; cursor: pointer; transition: border 0.2s, transform 0.2s; }
        .model-item:hover { border-color: var(--accent); transform: translateY(-2px); }
        .model-item.selected { border-color: var(--accent-strong); box-shadow: 0 0 0 1px var(--accent-strong); }
        .model-item.recommended { border-color: rgba(52,211,153,0.4); }
        .model-head { display: flex; justify-content: space-between; gap: 10px; align-items: center; flex-wrap: wrap; }
        .model-name { font-size: 16px; font-weight: 700; display: flex; gap: 8px; align-items: center; }
        .model-actions { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
        .status-pill { padding: 4px 8px; border-radius: 8px; font-size: 11px; font-weight: 700; letter-spacing: 0.02em; }
        .status-pill.ok { background: rgba(52,211,153,0.16); color: var(--success); }
        .status-pill.warn { background: rgba(244,63,94,0.16); color: var(--danger); }
        .model-meta { display: flex; flex-wrap: wrap; gap: 12px; color: var(--muted); font-size: 12px; margin: 6px 0 4px; }
        .model-reason { color: var(--success); font-size: 12px; }
        .pill { background: rgba(52,211,153,0.16); color: var(--success); border-radius: 999px; padding: 2px 8px; font-size: 10px; letter-spacing: 0.05em; font-weight: 700; }
        .selection-preview { margin-top: 12px; border: 1px dashed var(--border); border-radius: 12px; padding: 12px; background: #ffffff; color: var(--muted); font-size: 13px; }
        .selection-preview strong { color: var(--text); }
        .selection-preview .risk { color: var(--danger); font-weight: 700; }
        .timeline-wrapper { max-height: 280px; overflow-y: auto; padding-right: 6px; }
        .timeline { list-style: none; display: flex; flex-direction: column; gap: 10px; }
        .timeline-entry { display: flex; gap: 12px; padding: 10px; border: 1px solid var(--border); border-radius: 12px; background: #ffffff; }
        .timeline-dot { width: 12px; height: 12px; border-radius: 50%; margin-top: 6px; background: var(--accent); }
        .timeline-entry.success .timeline-dot { background: var(--success); }
        .timeline-entry.error .timeline-dot { background: var(--danger); }
        .timeline-entry.info .timeline-dot { background: var(--accent); }
        .timeline-time { font-size: 12px; color: var(--muted); }
        .timeline-text { font-size: 14px; }
        .timeline-empty { color: var(--muted); font-size: 13px; padding: 12px 4px; }
        .alert-stack { margin: 12px 0; }
        .alert { padding: 12px 14px; border-radius: 12px; font-weight: 700; border: 1px solid var(--border); }
        .alert.success { background: rgba(52,211,153,0.12); color: var(--success); border-color: rgba(52,211,153,0.3); }
        .alert.error { background: rgba(244,63,94,0.12); color: var(--danger); border-color: rgba(244,63,94,0.3); }
        .alert.info { background: rgba(34,211,238,0.12); color: var(--accent); border-color: rgba(34,211,238,0.3); }
        .loading-state { text-align: center; padding: 24px 0; color: var(--muted); }
        .spinner { width: 26px; height: 26px; border: 3px solid var(--border); border-top-color: var(--accent); border-radius: 50%; margin: 0 auto 8px; animation: spin 0.9s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .predict-grid { display: grid; grid-template-columns: repeat(3, minmax(0,1fr)); gap: 10px; }
        .predict-output { border: 1px dashed var(--border); border-radius: 12px; padding: 12px; background: #ffffff; margin-top: 10px; font-size: 13px; }
        .balena-list { display: flex; flex-direction: column; gap: 10px; max-height: 340px; overflow-y: auto; padding-right: 4px; }
        .balena-item { border: 1px solid var(--border); border-radius: 12px; padding: 12px; background: #ffffff; display: flex; flex-direction: column; gap: 10px; }
        .balena-head { display: flex; justify-content: space-between; align-items: flex-start; gap: 12px; flex-wrap: wrap; }
        .balena-meta { color: var(--muted); font-size: 12px; display: flex; flex-direction: column; gap: 3px; }
        .balena-actions { display: flex; gap: 8px; align-items: center; }
        .mini-btn { border: 1px solid var(--border); background: transparent; color: var(--accent); border-radius: 10px; padding: 6px 10px; font-size: 12px; cursor: pointer; }
        .monitor-tabs { display:flex; gap:12px; align-items:flex-end; border-bottom:1px solid var(--border); padding-bottom:6px; margin-bottom:14px; flex-wrap:wrap; }
        .monitor-tab { padding:10px 2px; border:none; border-bottom:2px solid transparent; background:transparent; color:var(--muted); cursor:pointer; font-weight:700; letter-spacing:0.02em; }
        .monitor-tab.active { color: var(--text); border-bottom-color: var(--accent); }
        .monitor-content { display:flex; flex-direction:column; gap:14px; }
        .monitor-row { display:grid; grid-template-columns: repeat(auto-fit, minmax(320px,1fr)); gap:12px; }
        .monitor-card { border:1px solid var(--border); border-radius:14px; padding:14px; background: linear-gradient(180deg, #ffffff, #eef3ff); color:var(--muted); box-shadow: 0 10px 26px rgba(15,23,42,0.08); transition: transform 0.2s ease, box-shadow 0.2s ease; }
        .monitor-card:hover { transform: translateY(-2px); box-shadow: 0 12px 32px rgba(15,23,42,0.12); }
        .monitor-card h4 { color: var(--text); margin-bottom:6px; font-size:16px; }
        .monitor-card small { color: var(--muted); }
        .bar-row { display:flex; align-items:center; gap:8px; margin:6px 0; }
        .bar { height:8px; border-radius:8px; background: linear-gradient(90deg, #22d3ee, #0ea5e9); flex:1; }
        .kpi { display:flex; flex-direction:column; gap:4px; padding:12px; border:1px solid var(--border); border-radius:12px; background:#ffffff; }
        .kpi small { color: var(--muted); }
        .kpi strong { font-size:18px; }
        .metric-list { display:flex; flex-direction:column; gap:6px; }
        .metric-line { display:flex; align-items:center; gap:10px; }
        .metric-line span.label { min-width:120px; color:var(--text); font-weight:600; }
        .metric-line .value { color:var(--muted); min-width:80px; text-align:right; }
        .pill-sm { padding:4px 8px; border-radius:999px; font-size:11px; border:1px solid var(--border); color:var(--text); background: rgba(34,211,238,0.08); }
        .view-tabs { 
            display: flex; 
            gap: 0; 
            margin: 12px 0 18px; 
            border-bottom: 2px solid var(--border);
            padding-bottom: 0;
        }
        .view-tab { 
            padding: 12px 24px; 
            border: none;
            border-bottom: 3px solid transparent;
            background: transparent;
            color: var(--muted); 
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            margin-bottom: -2px;
            text-decoration: none;
        }
        .view-tab:hover {
            color: var(--text);
            background: rgba(34,211,238,0.05);
        }
        .view-tab.active { 
            color: var(--accent);
            border-bottom-color: var(--accent);
            font-weight: 700;
        }
        .device-metrics { display:grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap:16px; margin-bottom:16px; }
        .metric-card { background: var(--panel); border: 1px solid var(--border); border-radius: 14px; padding: 16px; }
        .metric-card h4 { font-size: 14px; color: var(--muted); margin-bottom: 12px; text-transform: uppercase; letter-spacing: 0.5px; }
        .metric-value { font-size: 32px; font-weight: 700; margin: 8px 0; }
        .metric-bar-container { background: rgba(255,255,255,0.05); height: 12px; border-radius: 8px; overflow: hidden; margin-top: 8px; }
        .metric-bar { height: 100%; background: linear-gradient(90deg, var(--accent), var(--accent-strong)); transition: width 0.3s ease; }
        .metric-bar.warning { background: linear-gradient(90deg, var(--warning), #f97316); }
        .metric-bar.danger { background: linear-gradient(90deg, var(--danger), #dc2626); }
        .metric-label { color: var(--muted); font-size: 13px; margin-top: 6px; }
        .sparkline { width: 100%; height: 44px; margin-top: 10px; display:block; }
        .chart-grid { display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap:12px; }
        .chart-card { border:1px solid var(--border); border-radius:14px; padding:14px; background: linear-gradient(180deg, #ffffff, #eef3ff); }
        .chart-title { display:flex; justify-content:space-between; align-items:flex-end; gap:10px; margin-bottom:10px; }
        .chart-title h4 { margin:0; font-size:16px; color:var(--text); }
        .chart-title small { color:var(--muted); }
        .chart-svg { width:100%; height:170px; display:block; border-radius:12px; background:#f8fafc; border:1px solid var(--border); }
        .gauge-row { display:grid; grid-template-columns: repeat(auto-fit, minmax(220px,1fr)); gap:12px; }
        .gauge-card { border:1px solid var(--border); border-radius:14px; padding:14px; background:#ffffff; display:flex; flex-direction:column; gap:10px; }
        .gauge-head { display:flex; justify-content:space-between; gap:12px; align-items:center; }
        .gauge-head h5 { margin:0; font-size:13px; color:var(--muted); text-transform:uppercase; letter-spacing:0.05em; }
        .gauge-head strong { font-size:16px; color:var(--text); }
        .gauge-svg { width:100%; height:120px; display:block; }
        .stacked-bar { height:12px; border-radius:8px; overflow:hidden; background: rgba(255,255,255,0.05); border:1px solid var(--border); display:flex; }
        .stacked-seg { height:100%; }
        .stacked-used { background: linear-gradient(90deg, var(--accent), var(--accent-strong)); }
        .stacked-free { background: rgba(148,163,184,0.18); }
        .analytics-grid { display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap:16px; }
        @media (max-width: 1200px) {
            .analytics-grid { grid-template-columns: 1fr; }
        }
        @media (max-width: 980px) {
            .chart-grid { grid-template-columns: 1fr; }
        }
        .service-status { display: flex; align-items: center; gap: 12px; padding: 12px; background: rgba(34,211,238,0.08); border-radius: 10px; }
        .service-status .dot { width: 12px; height: 12px; }
        .service-name { font-weight: 600; font-size: 16px; }
        .service-info { color: var(--muted); font-size: 13px; }
        .hidden { display:none; }
        @media (max-width: 1100px) {
            .grid { grid-template-columns: 1fr; }
            .energy-grid { grid-template-columns: repeat(2, minmax(0,1fr)); }
            .predict-grid { grid-template-columns: repeat(2, minmax(0,1fr)); }
        }
        @media (max-width: 720px) {
            .energy-grid { grid-template-columns: repeat(2, minmax(0,1fr)); }
            .predict-grid { grid-template-columns: 1fr; }
            .status-row { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="shell">
        <header class="page-title">
            <h1>IoT ML Energy Manager</h1>
            <p>Deploy ML models and monitor device energy & performance.</p>
        </header>

        <div class="view-tabs" id="view_tabs">
            <button class="view-tab" data-view="deployment">Deployment</button>
            <button class="view-tab" data-view="monitoring">Monitoring</button>
            <button class="view-tab" data-view="analytics">Model Analytics</button>
        </div>

        {% include 'deployment.html' %}
        {% include 'monitoring.html' %}
        {% include 'analytics.html' %}

    </div> <!-- end shell -->
    <script>
        let allModels = [];
        let selectedModel = null;
        let currentFilter = 'all';
        let statusInterval = null;
        let balenaDevices = [];
        const MAX_METRIC_POINTS = 120;
        let deviceMetricsHistory = [];
        let lastDeviceMetrics = null;
        let metricsPollInterval = null;
        let deployMetricsPollInterval = null;
        let logPollInterval = null;
        let activeMonitorTab = 'trends';

        let recommendedSet = new Set();
        let selectedDeviceBudget = null;
        const deviceStatusCache = {};
        let lastDeploymentByDevice = {};
        const DEFAULT_BUDGET_MWH = 100; // Default energy budget in mWh
        const deviceLogsView = {
            statusId: 'logs_status_panel',
            contentId: 'logs_content_panel',
            viewportId: 'logs_viewport_panel',
            filterId: 'logs_filter_panel',
            autoscrollId: 'logs_autoscroll_panel'
        };
        const INITIAL_VIEW = "{{ initial_view|default('deployment') }}";
        const DEVICE_ENERGY_BUDGETS = {
            'beaglebone': 80,
            'raspberry-pi-4': 150,
            'raspberry-pi-5': 180,
            'raspberry-pi-zero': 60,
            'jetson-nano': 250,
            'arduino': 30,
            'esp32': 40,
            'default': 100
        };

        function setActiveView(view) {
            console.log('🔄 Switching to view:', view);
            
            const deploymentView = document.getElementById('deployment_view');
            const monitoringView = document.getElementById('monitoring_view');
            const analyticsView = document.getElementById('analytics_view');
            const viewTabs = document.getElementById('view_tabs');

            console.log('📍 Found elements:', {
                deploymentView: !!deploymentView,
                monitoringView: !!monitoringView,
                analyticsView: !!analyticsView,
                viewTabs: !!viewTabs
            });

            if (viewTabs) {
                viewTabs.querySelectorAll('.view-tab').forEach(el => {
                    const v = el.dataset.view;
                    el.classList.toggle('active', v === view);
                });
            }
            if (deploymentView) deploymentView.classList.toggle('hidden', view !== 'deployment');
            if (monitoringView) monitoringView.classList.toggle('hidden', view !== 'monitoring');
            if (analyticsView) analyticsView.classList.toggle('hidden', view !== 'analytics');

            if (view === 'monitoring') {
                startMetricsPolling();
                renderMonitoringTab('trends');
                loadBalenaDevices(); // Load devices for selector
            } else {
                stopMetricsPolling();
            }
            
            if (view === 'analytics') {
                loadModelAnalytics();
            }
            
            console.log('✅ View switched to:', view);
        }

        function initViewRouting() {
            const path = window.location.pathname;
            let initial = INITIAL_VIEW || 'deployment';
            if (path.includes('/monitoring')) {
                initial = 'monitoring';
            } else if (path.includes('/deployment')) {
                initial = 'deployment';
            } else if (path.includes('/analytics')) {
                initial = 'analytics';
            }
            setActiveView(initial);
            
            // Setup tab click handlers
            const tabs = document.querySelectorAll('.view-tab');
            console.log('🔧 Setting up tab click handlers for', tabs.length, 'tabs');
            tabs.forEach(tab => {
                console.log('  - Tab:', tab.dataset.view, tab.textContent.trim());
                tab.addEventListener('click', () => {
                    const view = tab.dataset.view;
                    console.log('👆 Tab clicked:', view);
                    if (view) {
                        setActiveView(view);
                        window.history.pushState({}, '', `/${view}`);
                    }
                });
            });
        }

        window.addEventListener('DOMContentLoaded', () => {
            // Load deployment logs from server on page load
            loadDeploymentLogs();
            initViewRouting();

            const monitorRefreshBtn = document.getElementById('monitor_refresh_btn');
            if (monitorRefreshBtn) {
                monitorRefreshBtn.addEventListener('click', () => refreshDeviceMetrics());
            }

            renderMonitoringTab('trends');

            const filterSelect = document.getElementById('filter_select');
            if (filterSelect) {
                filterSelect.addEventListener('change', (evt) => {
                    setFilterActive(evt.target.value);
                    filterModels(evt.target.value);
                });
            }

            document.getElementById('model_list').addEventListener('click', (evt) => {
                const downloadBtn = evt.target.closest('[data-download]');
                if (downloadBtn) {
                    evt.stopPropagation();
                    const modelName = decodeURIComponent(downloadBtn.dataset.download);
                    handleDownload(modelName, downloadBtn);
                    return;
                }
                const item = evt.target.closest('.model-item');
                if (!item) return;
                selectModel(decodeURIComponent(item.dataset.model));
            });

            const balenaList = document.getElementById('balena_device_list');
            if (balenaList) {
                balenaList.addEventListener('click', (evt) => {
                    const button = evt.target.closest('[data-endpoint]');
                    if (!button) return;
                    evt.preventDefault();
                    const endpoint = button.dataset.endpoint ? decodeURIComponent(button.dataset.endpoint) : '';
                    const name = button.dataset.name ? decodeURIComponent(button.dataset.name) : '';
                    useBalenaEndpoint(endpoint, name);
                });
            }

            const balenaRefreshBtn = document.getElementById('balena_refresh_btn');
            if (balenaRefreshBtn) {
                balenaRefreshBtn.addEventListener('click', () => loadBalenaDevices(true));
            }

            const balenaAppFilter = document.getElementById('balena_app_filter');
            if (balenaAppFilter) {
                balenaAppFilter.addEventListener('change', () => {
                    loadBalenaDevices();
                });
            }

            const monitorDeviceSelector = document.getElementById('monitor_device_selector');
            if (monitorDeviceSelector) {
                monitorDeviceSelector.addEventListener('change', (e) => {
                    const selectedIp = e.target.value;
                    if (selectedIp) {
                        document.getElementById('bbb_ip').value = selectedIp;
                        refreshDeviceMetrics({ silent: false });
                    }
                });
            }

            const analyticsRefreshBtn = document.getElementById('analytics_refresh_btn');
            if (analyticsRefreshBtn) {
                analyticsRefreshBtn.addEventListener('click', () => loadModelAnalytics());
            }

            loadInitialData();
            startStatusPolling();
            renderSelectionPreview();
            updateFilterCount(0);
            renderEnergyMetrics(null);
            loadBalenaFleets();
            loadBalenaDevices();
        });

        async function loadInitialData() {
            showLoading();
            try {
                await Promise.all([loadRecommendations(), loadAllModels()]);
            } catch (err) {
                console.error(err);
            }
        }

        async function loadRecommendations() {
            try {
                const resp = await fetch(`/api/models/recommended?device_type=BBB&max_energy=${DEFAULT_BUDGET_MWH}`);
                const data = await resp.json();
                if (data.success) {
                    const names = (data.recommendations || []).map(m => m.name);
                    recommendedSet = new Set(names);
                    applyRecommendationsToModels();
                    displayStats(data.stats);
                    showAlert('success', 'Loaded recommended models.');
                } else {
                    updateFilterCount(allModels.length || 0);
                    showAlert('error', data.error || 'Unable to load recommendations.');
                }
            } catch (err) {
                updateFilterCount(allModels.length || 0);
                showAlert('error', 'Failed to load data: ' + err);
            }
        }

        async function loadAllModels() {
            try {
                const resp = await fetch('/api/models/all');
                const data = await resp.json();
                if (data.success) {
                    allModels = data.models || [];
                applyRecommendationsToModels();
                selectedModel = null;
                displayStats(data.stats || null);
                setFilterActive('all');
                filterModels('all');
                renderSelectionPreview();
                    document.getElementById('deploy_btn').disabled = true;
                    updateFilterCount(allModels.length || 0);
                    showAlert('info', 'Loaded full model list.');
                } else {
                    updateFilterCount(allModels.length || 0);
                    showAlert('error', data.error || 'Unable to load model list.');
                }
            } catch (err) {
                updateFilterCount(allModels.length || 0);
                showAlert('error', 'Failed to load data: ' + err);
            }
        }

        function applyRecommendationsToModels() {
            if (!Array.isArray(allModels) || !allModels.length) return;
            allModels = allModels.map(m => ({
                ...m,
                recommended: recommendedSet.has(m.name)
            }));
        }

        function filterModels(type) {
            currentFilter = type;
            renderModelList();
        }

        function isLibraryModel(model) {
            if (!model || typeof model !== 'object') return false;
            if (model.is_library != null) return Boolean(model.is_library);
            if (model.library != null) return Boolean(model.library);
            if (model.source) {
                return String(model.source).toLowerCase().includes('library');
            }
            return false;
        }

        function renderModelList() {
            let filtered = [...allModels];

            // Then apply additional filters
            switch (currentFilter) {
                case 'recommended':
                    filtered = filtered.filter(m => m.recommended);
                    break;
                case 'under_50':
                case 'low_energy':
                    filtered = filtered.filter(m => Number(m.energy_mwh) < 50);
                    break;
                case 'under_100':
                    filtered = filtered.filter(m => Number(m.energy_mwh) < 100);
                    break;
                case 'small_size':
                    filtered = filtered.filter(m => Number(m.size_mb) < 30);
                    break;
                default:
                    break;
            }
            if (selectedModel && !filtered.some(m => m.name === selectedModel)) {
                selectedModel = null;
            }
            updateFilterCount(filtered.length);
            displayModels(filtered);
            document.getElementById('deploy_btn').disabled = !selectedModel;
            renderSelectionPreview();
        }

        function updateFilterCount(count) {
            const note = document.getElementById('filter_result_note');
            if (!note) return;
            const label = count === 1 ? 'model available' : 'models available';
            note.textContent = `${count} ${label} after filters`;
        }

        function displayModels(models) {
            const container = document.getElementById('model_list');
            if (!models || models.length === 0) {
                container.innerHTML = '<div class="loading-state">No models match the current filter.</div>';
                return;
            }
            container.innerHTML = models.map(model => {
                const rawName = model.name || 'Unnamed model';
                const encodedName = encodeURIComponent(rawName);
                const escapedName = escapeHtml(rawName);
                const reason = model.reason ? `<div class="model-reason">${escapeHtml(model.reason)}</div>` : '';
                const selectedClass = selectedModel === model.name ? 'selected' : '';
                const recommendedClass = model.recommended ? 'recommended' : '';
                const badge = model.recommended ? '<span class="pill">Recommended</span>' : '';
                const downloadStatus = model.downloaded ? '<span class="status-pill ok">Downloaded</span>' : '<span class="status-pill warn">Not downloaded</span>';
                const downloadBtn = model.downloaded ? '' : `<button class="mini-btn" data-download="${encodedName}">Download</button>`;
                return `
                    <div class="model-item ${selectedClass} ${recommendedClass}" data-model="${encodedName}">
                        <div class="model-head">
                            <div class="model-name">${escapedName}${badge}</div>
                            <div class="model-actions">
                                ${downloadStatus}
                                ${downloadBtn}
                            </div>
                        </div>
                        <div class="model-meta">
                            <span>Energy: <strong>${formatMetric(model.energy_mwh, 2)} mWh</strong></span>
                            <span>Size: <strong>${formatMetric(model.size_mb, 2)} MB</strong></span>
                            <span>Latency: <strong>${formatMetric(model.latency_s, 3)} s</strong></span>
                            <span>Params: <strong>${formatMetric(model.params_m, 2)} M</strong></span>
                        </div>
                        ${reason}
                    </div>
                `;
            }).join('');
        }

        function selectModel(modelName) {
            selectedModel = modelName;
            renderModelList();
            renderSelectionPreview();
            showAlert('info', `Selected ${modelName}`);
        }

        function deployModel() {
            if (!selectedModel) {
                showAlert('error', 'Please select a model before deploying.');
                return;
            }
            const bbbIp = (document.getElementById('bbb_ip').value || '').trim();
            if (!bbbIp) {
                showAlert('error', 'Please enter the device IP before deploying.');
                return;
            }
            const energyBudget = DEFAULT_BUDGET_MWH;
            const modelDetails = getModelByName(selectedModel);
            let forceDeploy = false;
            if (modelDetails && Number(modelDetails.energy_mwh) > energyBudget) {
                const confirmOverride = window.confirm(
                    `This model is estimated at ${modelDetails.energy_mwh} mWh, above the ${energyBudget} mWh budget. Continue anyway?`
                );
                if (!confirmOverride) {
                    showAlert('error', 'Deployment cancelled (over budget).');
                    showDeploymentLog('Deployment cancelled (over budget).', 'error');
                    return;
                }
                forceDeploy = true;
            }
            showAlert('info', 'Deploying model...');
            showDeploymentLog(`Starting deployment: ${selectedModel} -> ${bbbIp}`, 'info');
            if (energyBudget !== null) {
                showDeploymentLog(`Energy budget: ${energyBudget} mWh`, 'info');
            }
            document.getElementById('deploy_btn').disabled = true;
            fetch('/api/deploy', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    bbb_ip: bbbIp,
                    model_name: selectedModel,
                    max_energy: energyBudget,
                    force: forceDeploy
                })
            })
            .then(r => r.json())
            .then(data => {
                document.getElementById('deploy_btn').disabled = false;
                if (data.success) {
                    showAlert('success', 'Deployment completed.');
                    showDeploymentLog(`Deployment completed: ${selectedModel} (${data.model_info.energy_avg_mwh} mWh)`, 'success');
                    if (data.energy_budget_mwh) {
                        showDeploymentLog(`Monitoring with budget ${data.energy_budget_mwh} mWh`, 'info');
                        // Start energy monitoring (simulated)
                        startEnergyMonitoring(selectedModel, data.energy_budget_mwh);
                    }
                } else {
                    const errorMsg = data.error || 'Unknown error';
                    showAlert('error', 'Deployment failed: ' + errorMsg);
                    showDeploymentLog(`Deployment error: ${errorMsg}`, 'error');
                    
                    // Show helpful message for connection errors
                    if (errorMsg.includes('connect') || errorMsg.includes('Connection') || errorMsg.includes('refused')) {
                        showAlert('warning', 'Check: device online, correct IP, agent running on port 8000.');
                    }
                }
            })
            .catch(err => {
                document.getElementById('deploy_btn').disabled = false;
                const errMsg = String(err);
                showAlert('error', 'Unable to connect: ' + errMsg);
                showDeploymentLog('Unable to connect to controller or device.', 'error');
                
                // Additional guidance for common errors
                if (errMsg.includes('Failed to fetch') || errMsg.includes('NetworkError')) {
                    showAlert('warning', 'Network error: check that the controller server is running.');
                }
            });
        }

        function handleDownload(modelName, buttonEl) {
            if (!modelName) return;
            const btn = buttonEl || null;
            const originalText = btn ? btn.textContent : '';
            if (btn) {
                btn.disabled = true;
                btn.textContent = 'Downloading...';
            }
            showAlert('info', `Downloading model ${modelName}...`);
            fetch('/api/models/download', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ model_name: modelName })
            })
                .then(r => r.json())
                .then(data => {
                    if (data.success) {
                        allModels = allModels.map(m => m.name === modelName ? { ...m, downloaded: true } : m);
                        showAlert('success', data.message || `Downloaded ${modelName}`);
                        renderModelList();
                    } else {
                        showAlert('error', data.error || `Download failed: ${modelName}`);
                    }
                })
                .catch(err => showAlert('error', 'Download error: ' + err))
                .finally(() => {
                    if (btn) {
                        btn.disabled = false;
                        btn.textContent = originalText || 'Download';
                    }
                });
        }

        let energyMonitoringInterval = null;
        
        function startEnergyMonitoring(modelName, budget) {
            // Clear existing interval
            if (energyMonitoringInterval) {
                clearInterval(energyMonitoringInterval);
            }
            
            // Update budget display
            document.getElementById('energy_budget_value').textContent = budget.toFixed(1);
            
            // Initial fetch
            updateEnergyMonitoring(modelName, budget);
            
            // Poll every 5 seconds
            energyMonitoringInterval = setInterval(() => {
                updateEnergyMonitoring(modelName, budget);
            }, 5000);
        }
        
        function updateEnergyMonitoring(modelName, budget) {
            fetch(`/api/energy/monitor?model=${encodeURIComponent(modelName)}&duration=60`)
                .then(res => res.json())
                .then(data => {
                    if (data.success && data.readings && data.readings.length > 0) {
                        const stats = data.statistics;
                        const latest = data.readings[data.readings.length - 1];
                        
                        // Update cards
                        document.getElementById('energy_latest_value').textContent = latest.energy_mwh.toFixed(1);
                        document.getElementById('energy_avg_value').textContent = stats.average_mwh.toFixed(1);
                        
                        // Update status badge
                        const statusBadge = document.getElementById('energy_status_badge');
                        if (stats.average_mwh > budget) {
                            statusBadge.textContent = 'Over budget';
                            statusBadge.className = 'badge error';
                        } else {
                            statusBadge.textContent = 'Stable';
                            statusBadge.className = 'badge success';
                        }
                        
                        // Update history list (last 6 readings)
                        const historyList = document.getElementById('energy_history_list');
                        const recentReadings = data.readings.slice(-6).reverse();
                        historyList.innerHTML = recentReadings.map(reading => {
                            const time = new Date(reading.timestamp).toLocaleTimeString('en-US', {
                                hour: '2-digit',
                                minute: '2-digit',
                                second: '2-digit'
                            });
                            const status = reading.status === 'spike' ? ' (spike)' : '';
                            return `<li><span>${time}${status}</span><span>${reading.energy_mwh.toFixed(1)} mWh</span></li>`;
                        }).join('');
                    }
                })
                .catch(err => {
                    console.error('Failed to fetch energy monitoring data:', err);
                });
        }
        
        function stopEnergyMonitoring() {
            if (energyMonitoringInterval) {
                clearInterval(energyMonitoringInterval);
                energyMonitoringInterval = null;
            }
        }

        function predictEnergy() {
            const payload = {
                params_m: Number(document.getElementById('pred_params_m').value),
                gflops: Number(document.getElementById('pred_gflops').value),
                gmacs: Number(document.getElementById('pred_gmacs').value),
                size_mb: Number(document.getElementById('pred_size_mb').value),
                latency_avg_s: Number(document.getElementById('pred_latency').value),
                throughput_iter_per_s: Number(document.getElementById('pred_throughput').value),
            };
            const missing = Object.entries(payload).filter(([_, v]) => Number.isNaN(v));
            if (missing.length) {
                document.getElementById('predict_output').innerHTML = '<span style="color: var(--danger);">Please fill in all numeric fields.</span>';
                return;
            }
            document.getElementById('predict_output').innerHTML = `
                <div class="loading-state" style="padding:8px 0;">
                    <div class="spinner"></div>
                    Predicting energy...
                </div>
            `;
            fetch('/api/predict-energy', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(payload)
            })
            .then(r => r.json())
            .then(data => {
                if (!data.success) {
                    document.getElementById('predict_output').innerHTML = `<span style="color: var(--danger);">Error: ${escapeHtml(data.error || 'Unable to predict')}</span>`;
                    return;
                }
                const pred = data.predictions && data.predictions[0];
                if (!pred) {
                    document.getElementById('predict_output').innerHTML = '<span style="color: var(--danger);">No result returned.</span>';
                    return;
                }
                document.getElementById('predict_output').innerHTML = `
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:6px;">
                        <span class="badge ${pred.prediction_mwh > (data.model_info?.energy_budget_mwh || 0) ? 'over' : 'ok'}">Energy Est.</span>
                        <strong style="font-size:18px;">${formatMetric(pred.prediction_mwh,2)} mWh</strong>
                        <span class="muted">CI: ${formatMetric(pred.ci_lower_mwh,2)} - ${formatMetric(pred.ci_upper_mwh,2)} mWh</span>
                    </div>
                    <div class="muted">Model: ${escapeHtml(pred.model_name || 'N/A')}</div>
                `;
            })
            .catch(err => {
                document.getElementById('predict_output').innerHTML = `<span style="color: var(--danger);">Connection error: ${escapeHtml(err)}</span>`;
            });
        }

        function prefillPredictFromSelection() {
            if (!selectedModel) {
                showAlert('error', 'No model selected to prefill parameters.');
                return;
            }
            const m = getModelByName(selectedModel);
            if (!m) {
                showAlert('error', 'Selected model details not found.');
                return;
            }
            document.getElementById('pred_params_m').value = m.params_m || '';
            document.getElementById('pred_gflops').value = m.gflops || '';
            document.getElementById('pred_size_mb').value = m.size_mb || '';
            document.getElementById('pred_latency').value = m.latency_s || '';
            document.getElementById('pred_throughput').value = m.throughput || '';
            showAlert('info', 'Prefilled available parameters. Add GMACs if missing.');
        }

        function loadBalenaFleets() {
            fetch('/api/balena/fleets')
                .then(r => r.json())
                .then(data => {
                    if (data.success && data.fleets) {
                        const select = document.getElementById('balena_app_filter');
                        if (!select) return;
                        select.innerHTML = '<option value="">All fleets</option>';
                        data.fleets.forEach(fleet => {
                            const opt = document.createElement('option');
                            opt.value = fleet.slug || fleet.name;
                            opt.textContent = fleet.name || fleet.slug;
                            select.appendChild(opt);
                        });
                    }
                })
                .catch(err => console.error('Failed to load Balena fleets:', err));
        }

        function loadBalenaDevices(showNotification = false) {
            const list = document.getElementById('balena_device_list');
            if (!list) return;
            showBalenaLoading();
            const params = new URLSearchParams();
            const appFilter = document.getElementById('balena_app_filter');
            const appValue = appFilter && appFilter.value ? appFilter.value.trim() : '';
            if (appValue) params.set('app', appValue);
            const onlineToggle = document.getElementById('balena_online_only');
            if (onlineToggle && onlineToggle.checked) params.set('online_only', 'true');
            const query = params.toString();
            const url = query ? `/api/balena/devices?${query}` : '/api/balena/devices';
            fetch(url)
                .then(r => r.json())
                .then(data => {
                    if (data.success) {
                        balenaDevices = data.devices || [];
                        renderBalenaDevices(balenaDevices);
                        if (showNotification) {
                            showAlert('success', 'Balena device list refreshed.');
                        }
                    } else {
                        showBalenaDevicesMessage(data.error || 'Unable to load Balena devices.', 'error');
                    }
                })
                .catch(err => showBalenaDevicesMessage('Unable to connect to Balena: ' + err, 'error'));
        }

        function showBalenaLoading() {
            const list = document.getElementById('balena_device_list');
            if (!list) return;
            list.innerHTML = `
                <div class="loading-state">
                    <div class="spinner"></div>
                    Loading Balena Cloud devices...
                </div>
            `;
        }

        function renderBalenaDevices(devices) {
            const message = document.getElementById('balena_devices_message');
            const list = document.getElementById('balena_device_list');
            if (!list) return;
            if (!devices.length) {
                if (message) message.textContent = '';
                list.innerHTML = '';
                return;
            }
            if (message) message.textContent = `Found ${devices.length} device(s)`;
            
            // Populate monitoring device selector
            const selector = document.getElementById('monitor_device_selector');
            if (selector) {
                const currentValue = selector.value;
                selector.innerHTML = '<option value="">Select a device</option>';
                devices.forEach(dev => {
                    if (dev.endpoint) {
                        const opt = document.createElement('option');
                        opt.value = dev.endpoint;
                        opt.textContent = `${dev.name || 'Device'} (${dev.endpoint}) ${dev.is_online ? '🟢' : '🔴'}`;
                        selector.appendChild(opt);
                    }
                });
                if (currentValue) selector.value = currentValue;
            }
            list.innerHTML = devices.map(dev => {
                const statusBadge = dev.is_online
                    ? '<span class="badge ok" data-badge="status">ONLINE</span>'
                    : '<span class="badge over" data-badge="status">OFFLINE</span>';
                const endpoint = dev.endpoint ? encodeURIComponent(dev.endpoint) : '';
                const name = dev.name ? encodeURIComponent(dev.name) : '';
                const deviceType = dev.app && dev.app.name ? dev.app.name : (dev.app && dev.app.slug ? dev.app.slug : 'N/A');
                return `
                    <div class="balena-item ${dev.is_online ? 'online' : 'offline'}">
                        <div class="balena-head">
                            <div>
                                <h4>${escapeHtml(dev.name || 'Device')}</h4>
                                ${statusBadge}
                            </div>
                            <div class="balena-actions">
                                ${dev.webconsole_url ? `<a class="mini-btn" href="${escapeHtml(dev.webconsole_url)}" target="_blank">Webconsole</a>` : ''}
                                ${dev.endpoint ? `<button class="mini-btn" data-endpoint="${endpoint}" data-name="${name}">Connect</button>` : ''}
                            </div>
                        </div>
                        <div class="balena-meta">
                            <span>UUID: ${escapeHtml(dev.uuid || '--')}</span>
                            <span>IP: ${escapeHtml(dev.ip_address || dev.vpn_address || '--')}</span>
                            <span>OS: ${escapeHtml(dev.os_version || '--')}</span>
                            <span>Type: ${escapeHtml(deviceType)}</span>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function showBalenaDevicesMessage(message, type = 'info') {
            const messageEl = document.getElementById('balena_devices_message');
            if (messageEl) {
                messageEl.textContent = message;
                messageEl.className = type === 'error' ? 'muted error' : (type === 'success' ? 'muted success' : 'muted');
            }
        }

        function useBalenaEndpoint(endpoint, name) {
            if (!endpoint) return;
            showBalenaDevicesMessage('', 'info');
            fetch(`/api/status?bbb_ip=${endpoint}`)
                .then(r => r.json())
                .then(data => {
                    if (data.success) {
                        updateDeviceStatus(data.status);
                        showBalenaDevicesMessage('', 'success');
                        const btns = document.querySelectorAll(`.mini-btn[data-endpoint="${encodeURIComponent(endpoint)}"]`);
                        btns.forEach(btn => btn.outerHTML = `<span class="badge ok">Connected</span>`);
                    } else {
                        showBalenaDevicesMessage(data.error || 'Connection failed', 'error');
                    }
                })
                .catch(err => showBalenaDevicesMessage('Unable to connect: ' + err, 'error'));
        }

        function startStatusPolling() {
            if (statusInterval) clearInterval(statusInterval);
            statusInterval = setInterval(() => {
                const bbbIp = (document.getElementById('bbb_ip').value || '').trim();
                if (!bbbIp) return;
                fetch(`/api/status?bbb_ip=${bbbIp}`)
                    .then(r => r.json())
                    .then(data => { 
                        if (data.success) {
                            updateDeviceStatus(data.status);
                        } else {
                            // Handle device offline/error gracefully
                            const deviceStatus = document.getElementById('device_status');
                            if (data.device_offline || data.device_timeout) {
                                deviceStatus.querySelector('.status-value').innerHTML = 
                                    `<span class="dot error"></span>Offline`;
                            } else {
                                deviceStatus.querySelector('.status-value').innerHTML = 
                                    `<span class="dot error"></span>Connection error`;
                            }
                        }
                    })
                    .catch(() => {
                        // Network error - show device as offline
                        const deviceStatus = document.getElementById('device_status');
                        if (deviceStatus) {
                            deviceStatus.querySelector('.status-value').innerHTML = 
                                `<span class="dot error"></span>Unavailable`;
                        }
                    });
            }, 5000);
        }

        function updateDeviceStatus(status) {
            const deviceStatus = document.getElementById('device_status');
            const modelStatus = document.getElementById('model_status');
            const normalized = (status && status.status) ? status.status : 'idle';
            const statusClass = ['idle', 'downloading', 'ready', 'running', 'error'].includes(normalized) ? normalized : 'idle';
            deviceStatus.querySelector('.status-value').innerHTML = `<span class="dot ${statusClass}"></span>${normalized.toUpperCase()}`;
            if (status && status.model_name) {
                modelStatus.querySelector('.status-value').textContent = status.model_name;
            } else {
                modelStatus.querySelector('.status-value').textContent = 'No model';
            }
            renderEnergyMetrics(status ? status.energy_metrics : null);
        }

        function displayStats(stats) {
            const mainTotal = document.getElementById('stat_total_main');
            const main50 = document.getElementById('stat_50_main');
            const main100 = document.getElementById('stat_100_main');
            if (!mainTotal || !main50 || !main100) return;
            if (!stats) {
                mainTotal.textContent = '—';
                main50.textContent = '—';
                main100.textContent = '—';
                return;
            }
            mainTotal.textContent = stats.total_models ?? 0;
            main50.textContent = stats.models_under_50mwh ?? 0;
            main100.textContent = stats.models_under_100mwh ?? 0;
        }

        function renderEnergyMetrics(metrics) {
            const budgetEl = document.getElementById('energy_budget_value');
            const latestEl = document.getElementById('energy_latest_value');
            const avgEl = document.getElementById('energy_avg_value');
            const badge = document.getElementById('energy_status_badge');
            const historyEl = document.getElementById('energy_history_list');
            if (!metrics) {
                budgetEl.textContent = 'N/A';
                latestEl.textContent = 'N/A';
                avgEl.textContent = 'N/A';
                badge.textContent = 'No data';
                badge.className = 'badge';
                historyEl.innerHTML = '<li><span>No samples yet</span><span></span></li>';
                return;
            }
            const budget = metrics.budget_mwh;
            const latest = metrics.latest_mwh;
            const average = metrics.avg_mwh;
            const history = Array.isArray(metrics.history) ? metrics.history.slice(-6).reverse() : [];
            budgetEl.textContent = budget != null ? formatMetric(budget, 2) : 'N/A';
            latestEl.textContent = latest != null ? formatMetric(latest, 2) : 'N/A';
            avgEl.textContent = average != null ? formatMetric(average, 2) : 'N/A';
            const state = metrics.status === 'over_budget' ? 'over' : 'ok';
            badge.textContent = state === 'over' ? 'Over budget' : 'OK';
            badge.className = `badge ${state === 'over' ? 'over' : 'ok'}`;
            if (!history.length) {
                historyEl.innerHTML = '<li><span>No samples yet</span><span></span></li>';
            } else {
                historyEl.innerHTML = history.map(item => `
                    <li><span>${formatTimestamp(item.timestamp)}</span><span>${formatMetric(item.energy_mwh, 2)} mWh</span></li>
                `).join('');
            }
        }

        function startMetricsPolling() {
            // Start polling device metrics (to be implemented)
            console.log('📊 Started metrics polling');
        }

        function stopMetricsPolling() {
            // Stop polling device metrics
            console.log('⏸️ Stopped metrics polling');
        }

        function refreshDeviceMetrics(options = {}) {
            const bbbIp = document.getElementById('bbb_ip')?.value || 
                         document.getElementById('monitor_device_selector')?.value;
            
            if (!bbbIp) {
                if (!options.silent) {
                    showAlert('error', 'Please select a device first');
                }
                return;
            }

            console.log('🔄 Refreshing metrics for device:', bbbIp);
            
            // Update service status
            const serviceDot = document.getElementById('service_dot');
            const serviceState = document.getElementById('service_state');
            const serviceBadge = document.getElementById('service_badge');
            const lastUpdate = document.getElementById('monitor_last_update');
            
            if (serviceDot) serviceDot.className = 'dot downloading';
            if (serviceState) serviceState.textContent = 'checking...';
            if (serviceBadge) {
                serviceBadge.textContent = 'Checking...';
                serviceBadge.className = 'badge';
            }
            
            // Fetch device metrics
            fetch(`/api/status?bbb_ip=${encodeURIComponent(bbbIp)}`)
                .then(res => res.json())
                .then(data => {
                    if (data.success && data.status) {
                        const status = data.status.status || 'unknown';
                        
                        if (serviceDot) {
                            serviceDot.className = `dot ${status === 'ready' || status === 'running' ? 'ready' : 'idle'}`;
                        }
                        if (serviceState) serviceState.textContent = status;
                        if (serviceBadge) {
                            serviceBadge.textContent = status.toUpperCase();
                            serviceBadge.className = `badge ${status === 'ready' || status === 'running' ? 'ok' : ''}`;
                        }
                        if (lastUpdate) lastUpdate.textContent = new Date().toLocaleTimeString();
                        
                        if (!options.silent) {
                            showAlert('success', 'Device metrics refreshed');
                        }
                    } else {
                        if (serviceDot) serviceDot.className = 'dot error';
                        if (serviceState) serviceState.textContent = 'offline';
                        if (serviceBadge) {
                            serviceBadge.textContent = 'Offline';
                            serviceBadge.className = 'badge over';
                        }
                        if (!options.silent) {
                            showAlert('error', data.error || 'Failed to connect to device');
                        }
                    }
                })
                .catch(err => {
                    console.error('Failed to refresh metrics:', err);
                    if (serviceDot) serviceDot.className = 'dot error';
                    if (serviceState) serviceState.textContent = 'error';
                    if (serviceBadge) {
                        serviceBadge.textContent = 'Error';
                        serviceBadge.className = 'badge over';
                    }
                    if (!options.silent) {
                        showAlert('error', 'Connection error: ' + err.message);
                    }
                });
        }

        function renderMonitoringTab(tab) {
            const container = document.getElementById('monitor_content');
            if (!container) return;

            const safeTab = tab || 'trends';
            activeMonitorTab = safeTab;

            const hasHistory = Array.isArray(deviceMetricsHistory) && deviceMetricsHistory.length > 1;
            if (!hasHistory) {
                container.innerHTML = '<div class="monitor-card">No device metrics yet. Open Monitoring and wait for samples.</div>';
                return;
            }

            if (safeTab === 'trends') {
                container.innerHTML = `
                    <div class="chart-grid">
                        <div class="chart-card">
                            <div class="chart-title"><h4>CPU</h4><small>Last samples</small></div>
                            <svg class="chart-svg" id="trend_cpu" viewBox="0 0 600 180" preserveAspectRatio="none"></svg>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title"><h4>Temperature</h4><small>Last samples</small></div>
                            <svg class="chart-svg" id="trend_temp" viewBox="0 0 600 180" preserveAspectRatio="none"></svg>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title"><h4>Memory</h4><small>Used %</small></div>
                            <svg class="chart-svg" id="trend_mem" viewBox="0 0 600 180" preserveAspectRatio="none"></svg>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title"><h4>Storage</h4><small>Used %</small></div>
                            <svg class="chart-svg" id="trend_disk" viewBox="0 0 600 180" preserveAspectRatio="none"></svg>
                        </div>
                    </div>
                `;
                drawLineChart(document.getElementById('trend_cpu'), deviceMetricsHistory.map(p => p.cpuPercent), 0, 100);
                drawLineChart(document.getElementById('trend_temp'), deviceMetricsHistory.map(p => p.temperatureC), 0, 90);
                drawLineChart(document.getElementById('trend_mem'), deviceMetricsHistory.map(p => p.memUsedPercent), 0, 100);
                drawLineChart(document.getElementById('trend_disk'), deviceMetricsHistory.map(p => p.diskUsedPercent), 0, 100);
                return;
            }

            if (safeTab === 'distribution') {
                container.innerHTML = `
                    <div class="chart-grid">
                        <div class="chart-card">
                            <div class="chart-title"><h4>CPU distribution</h4><small>Histogram</small></div>
                            <svg class="chart-svg" id="hist_cpu" viewBox="0 0 600 180" preserveAspectRatio="none"></svg>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title"><h4>Temperature distribution</h4><small>Histogram</small></div>
                            <svg class="chart-svg" id="hist_temp" viewBox="0 0 600 180" preserveAspectRatio="none"></svg>
                        </div>
                    </div>
                `;
                drawHistogram(document.getElementById('hist_cpu'), deviceMetricsHistory.map(p => p.cpuPercent), 0, 100);
                drawHistogram(document.getElementById('hist_temp'), deviceMetricsHistory.map(p => p.temperatureC), 0, 90);
                return;
            }

            container.innerHTML = '<div class="monitor-card">Select a tab to view charts.</div>';
        }

        function renderGaugeCard(title, value, min, max, unit) {
            const v = (typeof value === 'number') ? value : null;
            const pct = v == null ? 0 : Math.max(0, Math.min(1, (v - min) / ((max - min) || 1)));
            const display = v == null ? 'N/A' : `${formatMetric(v, unit === '%' ? 0 : 1)}${unit}`;
            const stroke = v == null ? 'rgba(148,163,184,0.4)' : 'var(--accent)';
            const dash = Math.round(pct * 283);

            return `
                <div class="gauge-card">
                    <div class="gauge-head"><h5>${escapeHtml(title)}</h5><strong>${escapeHtml(display)}</strong></div>
                    <svg class="gauge-svg" viewBox="0 0 200 120">
                        <path d="M20 110 A80 80 0 0 1 180 110" fill="none" stroke="rgba(148,163,184,0.18)" stroke-width="12" />
                        <path d="M20 110 A80 80 0 0 1 180 110" fill="none" stroke="${stroke}" stroke-width="12" stroke-linecap="round" stroke-dasharray="${dash} 283" />
                    </svg>
                </div>
            `;
        }

        function renderUsedFreeBar(resource) {
            if (!resource || typeof resource.total_bytes !== 'number' || typeof resource.used_bytes !== 'number') {
                return '<div class="muted">N/A</div>';
            }
            const total = resource.total_bytes;
            const used = resource.used_bytes;
            const free = Math.max(0, total - used);
            const usedPct = total ? Math.max(0, Math.min(100, (used / total) * 100)) : 0;
            const freePct = 100 - usedPct;
            const usedGB = used / (1024 * 1024 * 1024);
            const totalGB = total / (1024 * 1024 * 1024);
            return `
                <div class="stacked-bar" aria-label="Used vs free">
                    <div class="stacked-seg stacked-used" style="width:${usedPct.toFixed(2)}%"></div>
                    <div class="stacked-seg stacked-free" style="width:${freePct.toFixed(2)}%"></div>
                </div>
                <div class="inline-stats" style="margin-top: 10px;">
                    <span>Used<strong>${formatMetric(usedGB, 2)} GB</strong></span>
                    <span>Free<strong>${formatMetric(free / (1024 * 1024 * 1024), 2)} GB</strong></span>
                    <span>Total<strong>${formatMetric(totalGB, 2)} GB</strong></span>
                </div>
            `;
        }

        function drawLineChart(svgEl, values, minY, maxY) {
            if (!svgEl) return;
            const series = (Array.isArray(values) ? values : []).filter(v => typeof v === 'number');
            const v = series.slice(-80);
            if (v.length < 2) { svgEl.innerHTML = ''; return; }

            const width = 600;
            const height = 180;
            const padX = 10;
            const padY = 12;
            const min = (typeof minY === 'number') ? minY : Math.min(...v);
            const max = (typeof maxY === 'number') ? maxY : Math.max(...v);
            const span = (max - min) || 1;

            const pts = v.map((val, i) => {
                const x = padX + (i / (v.length - 1)) * (width - padX * 2);
                const y = (height - padY) - ((val - min) / span) * (height - padY * 2);
                return `${x.toFixed(1)},${y.toFixed(1)}`;
            }).join(' ');

            const area = `M ${padX},${height - padY} L ${pts.replace(/\s+/g, ' L ')} L ${width - padX},${height - padY} Z`;

            svgEl.innerHTML = `
                <defs>
                    <linearGradient id="areaFill" x1="0" y1="0" x2="0" y2="1">
                        <stop offset="0%" stop-color="rgba(34,211,238,0.25)" />
                        <stop offset="100%" stop-color="rgba(34,211,238,0)" />
                    </linearGradient>
                </defs>
                <path d="${area}" fill="url(#areaFill)" />
                <polyline fill="none" stroke="var(--accent)" stroke-width="2" points="${pts}" />
            `;
        }

        function drawHistogram(svgEl, values, minX, maxX) {
            if (!svgEl) return;
            const raw = (Array.isArray(values) ? values : []).filter(v => typeof v === 'number');
            const v = raw.slice(-200);
            if (v.length < 3) { svgEl.innerHTML = ''; return; }

            const width = 600;
            const height = 180;
            const bins = 12;
            const min = (typeof minX === 'number') ? minX : Math.min(...v);
            const max = (typeof maxX === 'number') ? maxX : Math.max(...v);
            const span = (max - min) || 1;
            const counts = new Array(bins).fill(0);
            for (const val of v) {
                const idx = Math.max(0, Math.min(bins - 1, Math.floor(((val - min) / span) * bins)));
                counts[idx] += 1;
            }
            const maxCount = Math.max(...counts, 1);

            const gap = 6;
            const barW = (width - gap * (bins + 1)) / bins;
            let bars = '';
            for (let i = 0; i < bins; i++) {
                const barH = (counts[i] / maxCount) * (height - 24);
                const x = gap + i * (barW + gap);
                const y = height - 12 - barH;
                bars += `<rect x="${x.toFixed(1)}" y="${y.toFixed(1)}" width="${barW.toFixed(1)}" height="${barH.toFixed(1)}" rx="6" fill="rgba(34,211,238,0.55)" />`;
            }
            svgEl.innerHTML = bars;
        }

        function renderParetoPlaceholder() {
            const container = document.getElementById('monitor_content');
            if (!container) return;
            container.innerHTML = '<div class="monitor-card">Model analytics are unavailable.</div>';
        }

        function renderMetricLine(label, value, maxValue, unit = '') {
            const safeMax = maxValue && maxValue > 0 ? maxValue : 1;
            const width = Math.min(100, Math.max(10, Math.round((value / safeMax) * 100)));
            return `
                <div class="metric-line">
                    <span class="label">${escapeHtml(label)}</span>
                    <div class="bar" style="width:${width}%;"></div>
                    <span class="value">${formatMetric(value, 2)} ${unit}</span>
                </div>
            `;
        }

        function renderKpi(label, value) {
            return `
                <div class="kpi">
                    <small>${escapeHtml(label)}</small>
                    <strong>${escapeHtml(value)}</strong>
                </div>
            `;
        }

        function parsePercent(value) {
            const num = Number(String(value || '').replace('%', ''));
            if (Number.isNaN(num)) return 0;
            return Math.min(100, Math.max(0, num));
        }

        function renderSelectionPreview() {
            const preview = document.getElementById('selection_preview');
            if (!preview) return;
            if (!selectedModel) { preview.textContent = 'Select a model to preview metrics and check the energy budget.'; return; }
            const model = getModelByName(selectedModel);
            if (!model) { preview.textContent = 'Model details not found in the dataset.'; return; }
            const parsedBudget = DEFAULT_BUDGET_MWH;
            const energy = Number(model.energy_mwh);
            const exceeding = !Number.isNaN(energy) && energy > parsedBudget;
            preview.innerHTML = `
                <div><strong>${escapeHtml(model.name)}</strong></div>
                <div>Energy: <strong>${formatMetric(model.energy_mwh, 2)} mWh</strong> ${exceeding ? '<span class="risk">Over budget</span>' : ''}</div>
                <div>Budget: <strong>${formatMetric(parsedBudget, 2)} mWh</strong></div>
                <div>Size: <strong>${formatMetric(model.size_mb, 2)} MB</strong> • Latency: <strong>${formatMetric(model.latency_s, 3)} s</strong></div>
            `;
        }

        function getModelByName(name) {
            if (!name) return null;
            return allModels.find(model => model.name === name) || null;
        }

        function showAlert(type, message) {
            const container = document.getElementById('alert_container');
            container.innerHTML = `<div class="alert ${type}">${message}</div>`;
            setTimeout(() => { container.innerHTML = ''; }, 5000);
        }

        function showLoading() {
            document.getElementById('model_list').innerHTML = `
                <div class="loading-state">
                    <div class="spinner"></div>
                    Loading data from controller...
                </div>
            `;
        }

        function loadDeploymentLogs() {
            fetch('/api/logs?limit=50')
                .then(res => res.json())
                .then(data => {
                    if (data.success && data.logs && data.logs.length > 0) {
                        const placeholder = document.getElementById('deployment_log_placeholder');
                        if (placeholder) placeholder.style.display = 'none';
                        
                        const log = document.getElementById('deployment_log');
                        if (!log) {
                            console.warn('deployment_log element not found');
                            return;
                        }
                        log.innerHTML = ''; // Clear existing
                        
                        // Logs đã được reverse ở backend (mới nhất lên đầu)
                        // Reverse lại để hiển thị cũ nhất lên đầu
                        const sortedLogs = [...data.logs].reverse();
                        
                        sortedLogs.forEach(logEntry => {
                            const entry = document.createElement('li');
                            entry.className = `timeline-entry ${logEntry.type || 'info'}`;
                            
                            const timestamp = new Date(logEntry.timestamp);
                            const timeString = timestamp.toLocaleTimeString('vi-VN', {
                                hour: '2-digit',
                                minute: '2-digit',
                                second: '2-digit'
                            });
                            
                            entry.innerHTML = `
                                <span class="timeline-dot"></span>
                                <div>
                                    <p class="timeline-time">${timeString}</p>
                                    <p class="timeline-text">${escapeHtml(logEntry.message)}</p>
                                </div>
                            `;
                            log.appendChild(entry);
                        });
                        
                        // Scroll to bottom
                        const wrapper = document.getElementById('deployment_log_wrapper');
                        if (wrapper) {
                            wrapper.scrollTop = wrapper.scrollHeight;
                        }
                        
                        // Update stats nếu cần
                        if (data.stats) {
                            console.log('Deployment Stats:', data.stats);
                        }
                    }
                })
                .catch(err => {
                    console.error('Failed to load deployment logs:', err);
                });
        }

        function showDeploymentLog(message, level = 'info') {
            const placeholder = document.getElementById('deployment_log_placeholder');
            if (placeholder) placeholder.style.display = 'none';
            const log = document.getElementById('deployment_log');
            if (!log) {
                console.warn('deployment_log element not found');
                return;
            }
            const entry = document.createElement('li');
            entry.className = `timeline-entry ${level}`;
            entry.innerHTML = `
                <span class="timeline-dot"></span>
                <div>
                    <p class="timeline-time">${new Date().toLocaleTimeString()}</p>
                    <p class="timeline-text">${message}</p>
                </div>
            `;
            log.appendChild(entry);
            const wrapper = document.getElementById('deployment_log_wrapper');
            wrapper.scrollTop = wrapper.scrollHeight;
        }

        function setFilterActive(filter) {
            const select = document.getElementById('filter_select');
            if (select) {
                select.value = filter;
            }
        }

        function formatTimestamp(value) {
            if (!value) return '--';
            const date = new Date(value);
            if (Number.isNaN(date.getTime())) return escapeHtml(String(value));
            return date.toLocaleTimeString();
        }

        function escapeHtml(value = '') {
            return String(value)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function formatMetric(value, digits = 2) {
            if (value === undefined || value === null || value === '') return '—';
            const num = Number(value);
            if (Number.isNaN(num)) return escapeHtml(String(value));
            return Number(num.toFixed(digits));
        }

        // ============================================================================
        // MODEL ANALYTICS FUNCTIONS
        // ============================================================================

        function showAnalyticsAlert(msg) {
            const box = document.getElementById('analytics_alert_container');
            if (!box) return;
            
            if (!msg) {
                box.style.display = 'none';
                box.textContent = '';
                return;
            }
            
            // Determine alert type from message content
            let alertClass = 'info';
            if (msg.includes('Failed') || msg.includes('error') || msg.includes('⚠️')) {
                alertClass = 'error';
            } else if (msg.includes('Success') || msg.includes('✓')) {
                alertClass = 'success';
            }
            
            box.className = `alert ${alertClass}`;
            box.textContent = msg;
            box.style.display = 'block';
            
            // Auto-hide success messages after 5 seconds
            if (alertClass === 'success') {
                setTimeout(() => {
                    box.style.display = 'none';
                }, 5000);
            }
        }

        function renderParetoPlaceholder(message = 'Model analytics are unavailable.') {
            const container = document.getElementById('analytics_content');
            if (!container) return;
            container.innerHTML = `<div class="monitor-card">${escapeHtml(message)}</div>`;
        }

        function renderParetoAnalysis(models) {
            const container = document.getElementById('analytics_content');
            if (!container) return;

            const normalized = (Array.isArray(models) ? models : []).map(m => {
                const energy = Number(m.energy_mwh ?? m.energy_avg_mwh ?? m.energy);
                const latency = Number(m.latency_s ?? m.latency ?? m.latency_avg_s);
                const size = Number(m.size_mb ?? m.model_size_mb ?? m.size);
                const throughput = Number(m.throughput ?? m.throughput_iter_per_s ?? m.fps);
                return {
                    model: m.model || m.name || m.model_name || 'Unnamed model',
                    energy_mwh: energy,
                    latency_s: latency,
                    size_mb: size,
                    throughput
                };
            }).filter(m => (
                Number.isFinite(m.energy_mwh) && m.energy_mwh > 0 &&
                Number.isFinite(m.latency_s) && m.latency_s > 0 &&
                Number.isFinite(m.size_mb) && m.size_mb > 0 &&
                Number.isFinite(m.throughput) && m.throughput > 0
            ));

            if (!normalized.length) {
                renderParetoPlaceholder('No valid benchmark data found.');
                return;
            }

            const sortedByEnergy = [...normalized].sort((a, b) => a.energy_mwh - b.energy_mwh);
            const paretoFrontier = [];
            for (const model of sortedByEnergy) {
                const isDominated = sortedByEnergy.some(other =>
                    (other.energy_mwh <= model.energy_mwh && other.latency_s <= model.latency_s) &&
                    (other.energy_mwh < model.energy_mwh || other.latency_s < model.latency_s)
                );
                if (!isDominated) paretoFrontier.push(model);
            }

            const topEfficient = sortedByEnergy.slice(0, 15);
            const topCompact = [...normalized].sort((a, b) => a.size_mb - b.size_mb).slice(0, 15);
            const topEfficiencyModels = normalized
                .map(m => ({ ...m, efficiency: m.throughput / m.energy_mwh }))
                .filter(m => Number.isFinite(m.efficiency) && m.efficiency > 0)
                .sort((a, b) => b.efficiency - a.efficiency)
                .slice(0, 10);

            const maxEnergy = Math.max(...topEfficient.map(m => m.energy_mwh), 1);
            const maxLatency = Math.max(...topEfficient.map(m => m.latency_s), 1);
            const maxSize = Math.max(...topCompact.map(m => m.size_mb), 1);
            const maxEff = Math.max(...topEfficiencyModels.map(m => m.efficiency), 1);

            const stats = {
                total: normalized.length,
                avgEnergy: normalized.reduce((s, m) => s + m.energy_mwh, 0) / normalized.length,
                avgLatency: normalized.reduce((s, m) => s + m.latency_s, 0) / normalized.length,
                avgSize: normalized.reduce((s, m) => s + m.size_mb, 0) / normalized.length,
                minEnergy: Math.min(...normalized.map(m => m.energy_mwh)),
                maxEnergy: Math.max(...normalized.map(m => m.energy_mwh))
            };

            container.innerHTML = `
                <div class="monitor-card">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                        <h4>Energy vs Latency (Pareto Frontier)</h4>
                        <span class="badge ok" style="font-size: 11px;">${paretoFrontier.length} optimal</span>
                    </div>
                    <small style="color: var(--accent); font-weight: 600;">Models on the Pareto frontier (optimal energy + latency trade-off)</small>
                    <div class="metric-list" style="max-height: 420px; overflow-y: auto;">
                        ${topEfficient.map((model, idx) => {
                            const isParetoOptimal = paretoFrontier.some(p => p.model === model.model);
                            const energyWidth = Math.min(100, Math.round((model.energy_mwh / maxEnergy) * 100));
                            const latencyWidth = Math.min(100, Math.round((model.latency_s / maxLatency) * 100));
                            const borderStyle = isParetoOptimal ? 'border-left: 3px solid var(--accent); padding-left: 9px;' : '';
                            const bgStyle = isParetoOptimal ? 'background: rgba(34,211,238,0.06);' : '';
                            return `
                                <div class="metric-line" style="flex-direction:column; align-items:flex-start; margin-bottom: 12px; padding: 8px; border-radius: 8px; ${bgStyle} ${borderStyle}">
                                    <span class="label" style="font-size: 13px; font-weight: ${isParetoOptimal ? '700' : '500'}; display: flex; align-items: center; gap: 6px;">
                                        ${isParetoOptimal ? '⭐' : ''} ${idx + 1}. ${escapeHtml(model.model)}
                                    </span>
                                    <div style="display:flex; align-items:center; gap:8px; width:100%; margin-top: 4px;">
                                        <span style="font-size:11px; color:var(--muted); min-width:60px; font-weight: 600;">Energy</span>
                                        <div class="bar" style="width:${energyWidth}%; background: linear-gradient(90deg, #22d3ee, #0ea5e9);"></div>
                                        <span class="value" style="font-weight: 600;">${model.energy_mwh.toFixed(1)} mWh</span>
                                    </div>
                                    <div style="display:flex; align-items:center; gap:8px; width:100%; margin-top: 2px;">
                                        <span style="font-size:11px; color:var(--muted); min-width:60px; font-weight: 600;">Latency</span>
                                        <div class="bar" style="width:${latencyWidth}%; background: linear-gradient(90deg, #8b5cf6, #a855f7);"></div>
                                        <span class="value" style="font-weight: 600;">${model.latency_s.toFixed(3)} s</span>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                    <div style="margin-top: 12px; padding: 10px 12px; background: linear-gradient(135deg, rgba(34,211,238,0.12), rgba(16,185,129,0.08)); border-radius: 10px; border-left: 3px solid var(--accent); font-size: 12px; color: var(--text); font-weight: 500;">
                        💡 <strong>Pareto Optimal:</strong> These models cannot be improved in both energy and latency simultaneously—any improvement in one metric comes at the cost of the other.
                    </div>
                </div>
                <div class="monitor-card">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                        <h4>Energy vs Size Trade-off</h4>
                        <span class="badge ok" style="font-size: 11px; background: rgba(52,211,153,0.16); color: var(--success);">Top 15</span>
                    </div>
                    <small style="color: var(--success); font-weight: 600;">Smallest models (ideal for memory-constrained devices)</small>
                    <div class="metric-list" style="max-height: 420px; overflow-y: auto;">
                        ${topCompact.map((model, idx) => {
                            const energyWidth = Math.min(100, Math.round((model.energy_mwh / maxEnergy) * 100));
                            const sizeWidth = Math.min(100, Math.round((model.size_mb / maxSize) * 100));
                            return `
                                <div class="metric-line" style="flex-direction:column; align-items:flex-start; margin-bottom: 12px;">
                                    <span class="label" style="font-size: 12px;">
                                        ${idx + 1}. ${escapeHtml(model.model)}
                                    </span>
                                    <div style="display:flex; align-items:center; gap:8px; width:100%;">
                                        <span style="font-size:10px; color:var(--muted); min-width:60px;">Size</span>
                                        <div class="bar" style="width:${sizeWidth}%; background: linear-gradient(90deg, #34d399, #10b981);"></div>
                                        <span class="value">${model.size_mb.toFixed(1)} MB</span>
                                    </div>
                                    <div style="display:flex; align-items:center; gap:8px; width:100%;">
                                        <span style="font-size:10px; color:var(--muted); min-width:60px;">Energy</span>
                                        <div class="bar" style="width:${energyWidth}%; background: linear-gradient(90deg, #22d3ee, #0ea5e9);"></div>
                                        <span class="value">${model.energy_mwh.toFixed(1)} mWh</span>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
                <div class="monitor-card">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                        <h4>Efficiency Ranking</h4>
                        <span class="badge" style="font-size: 11px; background: rgba(251,191,36,0.16); color: var(--warning);">Top 10</span>
                    </div>
                    <small style="color: var(--warning); font-weight: 600;">Models by throughput per energy (best performance/cost ratio)</small>
                    <div class="metric-list">
                        ${topEfficiencyModels.map((model, idx) => {
                            const effWidth = Math.min(100, Math.round((model.efficiency / maxEff) * 100));
                            return `
                                <div class="metric-line">
                                    <span class="label" style="font-size: 12px;">${idx + 1}. ${escapeHtml(model.model)}</span>
                                    <div class="bar" style="width:${effWidth}%; background: linear-gradient(90deg, #fbbf24, #f59e0b);"></div>
                                    <span class="value" style="font-size: 11px;">${model.efficiency.toFixed(2)} iter/mWh</span>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
                <div class="monitor-card">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                        <h4>Summary Statistics</h4>
                        <span class="badge" style="font-size: 11px; background: rgba(59,130,246,0.12); color: var(--accent);">${stats.total} models</span>
                    </div>
                    <small style="color: var(--muted); font-weight: 600;">Complete benchmark dataset overview</small>
                    <div class="metric-list">
                        ${[
                            { label: 'Total Models', value: stats.total, unit: '' },
                            { label: 'Avg Energy', value: stats.avgEnergy, unit: ' mWh' },
                            { label: 'Avg Latency', value: stats.avgLatency, unit: ' s' },
                            { label: 'Avg Size', value: stats.avgSize, unit: ' MB' },
                            { label: 'Min Energy', value: stats.minEnergy, unit: ' mWh' },
                            { label: 'Max Energy', value: stats.maxEnergy, unit: ' mWh' }
                        ].map(stat => {
                            const val = (typeof stat.value === 'number' && !isNaN(stat.value) && isFinite(stat.value)) ? stat.value : 0;
                            return `
                            <div class="metric-line">
                                <span class="label">${stat.label}</span>
                                <span class="value">${val.toFixed(2)}${stat.unit}</span>
                            </div>
                        `;}).join('')}
                    </div>
                </div>
            `;
        }

        function loadModelAnalytics() {
            const container = document.getElementById('analytics_content');
            showAnalyticsAlert('');
            
            // Show loading state
            if (container) {
                container.innerHTML = `
                    <div class="loading-state" style="grid-column: 1 / -1; padding: 60px 20px;">
                        <div class="spinner"></div>
                        <p style="margin-top: 16px; font-size: 15px; color: var(--muted);">Analyzing model benchmarks...</p>
                        <p style="margin-top: 8px; font-size: 13px; color: var(--muted);">Calculating Pareto frontier and efficiency metrics</p>
                    </div>
                `;
            }
            
            fetch('/api/models/all')
                .then(res => res.json())
                .then(data => {
                    if (data.success && data.models) {
                        renderParetoAnalysis(data.models);
                        showAnalyticsAlert(''); // Clear any errors
                    } else {
                        showAnalyticsAlert(data.error || 'Failed to load analytics.');
                        renderParetoPlaceholder();
                    }
                })
                .catch(err => {
                    console.error('Failed to load model analytics:', err);
                    showAnalyticsAlert('⚠️ Failed to load analytics: ' + err);
                    renderParetoPlaceholder('Unable to connect to the server. Please check your connection and try again.');
                });
        }

        // ============================================================================
        // END MODEL ANALYTICS
        // ============================================================================
    
    </script>
</body>
</html>
